# ВОПРОСЫ И ОТВЕТЫ К ЭКЗАМЕНУ
## 1. Что такое сервер с позиции программного обеспечения?
*Сервер* - программный компонент вычислительной системы, выполняющий обслуживающие функции по запросу клиента, предоставляя ему доступ к определённым ресурсам или услугам.
## 2. Что такое сервер с позиции аппаратного обеспечения?
*Сервер* - специализированный компьютер для выполнения действий без непосредственного участия человека.
## 3. Что такое клиент?
*Клиент* - аппаратный или программный компонент вычислительной системы, посылающий запросы *серверу* при помощи протоколов.
## 4. Что такое база данных?
*База данных* - информационная модель, позволяющая упорядоченно хранить данные об объекте или группе объектов, обладающих набором свойств, которые можно категоризировать.
## 5. Что такое API?
*API* (клиент-серверная архитектура) - описание способов (классов, процедур, функций, структур), при помощи которых одна программа взаимодействует с другой программой.

*API* (общее определение) - (Application programming interface) контракт, который предоставляет программа.
## 6. Что такое сервис? Отличие сервиса от сервера.
*Сервис* - легко заменяемый компонент сервисно-ориентируемой архитектуры со стандартизируемым интерфейсом.
## 7. Что такое веб-служба?
*Веб-служба* - программная система, идентифицируемая уникальным адресом со стандартизируемым интерфейсом.
## 8. Что такое клиент-сервер как вычислительная модель?
*Клиент-сервер* - вычислительная или сетевая архитектура, в которой задания или сетевая нагрузка распределены между серверами и клиентами.
## 9. Из чего состоит модель клиент-сервера и её компоненты.
Модель состоит из *Клиента*, *Сервера* и *БД*.
## 10. Что такое архитектура клиент-сервер как модель?
*См. 8*
## 11. Перечислите достоинства клиент-серверной архитектуры.
+ Основная нагрузка ложится на сервер.
+ Разграничение доступа к данным.
+ Разграничение полномочий между клиентом и сервером.
+ Достижение кроссплотформенности для клиента.
## 12. Перечислите недостатки клиент-серверной архитектуры.
+ Высокая стоимость сервеного оборудования.
+ Поддержка системы требует отдельного специалиста.
+ Сбой в работе сервера повлечёт за собой сбой в работе всей системы.
## 13. Что такое веб-приложение и из каких основных компонентов состоит?
*Веб-приложение* — клиент-серверное приложение, в котором клиент взаимодействует с веб-сервером при помощи браузера. Логика веб-приложения распределена между сервером и клиентом, хранение данных осуществляется на сервере, обмен информацией происходит по сети.
## 14. Опишите существующие клиент-серверные конфигурации архитектуры.
...
## 15. Опишите отличия двухзвенной архитектуры от n-звенной.
Двухзвенная архитектура подходит для небольших приложений с малым количеством пользователей, запросов или данных по той причине, что её горизонтальное масштабирование затруднено.
## 16. Опишите достоинства n-звенной архитектуры
Плюсы двухзвенной архитектуры:
* основная нагрузка ложится на сервер
* разграничение доступа к данным
* разграничение полномочий между клиентом и сервером
* кроссплатформенность реализации клиента
## 17. Опишите несколько различных сервисов
Виды сервисов:
* Севреры приложений - программная платформа предназначенная для эффективного выполнения процедур.
* Веб-серверы - являются подвидом серверов приложений, изначально представляли доступ к гипертекстовым документам.
* Серверы баз данных - выполнение запросов и управление БД.
* Файл серверы - хранят информацию в виде файлов и предоставляет пользователям доступ, как правило, предоставляют уровень защиты доступа.
* Прокси-сервер - это промежуточный сервер либо комплекс программ выполняющий роль посредника.
- Веб-прокси - широкий класс прокси серверов, который служит для кеширования данных. 
- Обратный прокси - прокси сервер ретранслирует запросы клиентов из внешней сети на один или несколько серверов во внутренней сети, часто используется для балансировки сетевой нагрузки и повышении их безопасности.
* Файрволы (брандмауэры) - межсетевые экраны, которые анализируют и фильтруют входящий сетевой трафик.
* Почтовые серверы - предоставляют услуги по отправке и получению электронных почтовых сообщений.
## 18. Что такое прокси-сервер и как он классифицируется?
*Proxy-сервер* - промежуточный сервер в компьютерных сетях, выполняющий роль посредника между пользователем и целевым сервером, позволяющий клиентам как выполнять косвенные запросы к другим сетевым службам, так и получать ответы. Есть несколько видов прокси:
+ Прозрачный proxy
+ Обратный proxy
+ web-proxy
## 19. Раскройте и классифицируйте понятие масштабируемость.
*Масшабируемость* - способность системы, сети или процесса справляться с увеличением рабочей нагрузки при добавлении ресурсов.
*Вертикальная масштабируемость* - увеличение производительности компонентов системы для того, чтобы увеличить производительности всей системы.
*Горизонтальная масштабируемость* - как разбиение системы на более мелкие структурные компоненты и разнесение их, так и увеличение количества компонентов, параллельно выполняющих одну и ту же функцию.
## 20. Что такое протокол передачи данных и сетевой протокол?
*Протокол передачи данных* - набор определённых правил интерфейса логического уровня, который определяет обмен данными между программами и задаёт единый способ передачи сообщений.
*Сетевой протокол* - набор правил и действий, позволяющий осуществлять соединение и обмен данными между устройствами в сети.
## 21. Опишите классификацию протоколов.
+ IP

	Протокол передачи, который первым объединил отдельные компьютеры в единую сеть. Основная задача этого протокола - определение пути следования данных по узлам сети.
+ TCP/IP

	Cтек протоколов TCP и IP. Первый обеспечивает и контролирует надёжную передачу данных и следит за её целостностью. Второй же отвечает за маршрутизацию для отправки данных.
+ UDP

	Протокол, обеспечивающий передачу данных без предварительного создания соединения между ними. Этот протокол является ненадёжным. В нём пакеты могут не только не дойти, но и прийти не по порядку или вовсе продублироваться. Основное преимущество UDP протокола заключается в скорости доставки данных. Именно поэтому чувствительные к сетевым задержкам приложения часто используют этот тип передачи данных.
+ FTP

	Протокол передачи файлов. Работает по принципу клиент-серверной архитектуры. Пользователь проходит аутентификацию (хотя в отдельных случаях может подключаться анонимно) и получает доступ к файловой системе сервера.
+ HTTP

	Используется для передачи произвольных данных в интернете. Он является протоколом клиент-серверного взаимодействия без сохранения промежуточного состояния. В роли клиента чаще всего выступает веб-браузер. Для обмена информацией протокол HTTP в большинстве случаев использует TCP/IP.

## 22. Опишите кратко две основные, в настоящее время, сетевые модели.
+ *OSI*

	Модель была задумана для того, чтобы ответить на вопросы сетевой связи и установить стандарты коммуникаций для сетевых разработчиков. В модели есть 7 уровней:

    + Прикладной уровень
    + Уровень представления
	+ Сеансовый уровень
	+ Транспортный уровень
	+ Сетевой уровень
	+ Канальный уровень
	+ Физический уровень
+ *TCP/IP*

	Сетевая модель передачи данных, представленных в цифровом виде. Модель описывает способ передачи данных от источника информации к получателю. В модели предполагается прохождение информации через четыре уровня:
	+ Прикладной уровень
	+ Транспортный уровень
	+ Сетевой уровень
	+ Канальный уровень
## 23. Назовите основные прикладные протоколы, используемые в сети Интернет.
...
## 24. Опишите и определите понятия "толстый" и "тонкий" клиент.
*Тонкий клиент* - программы, задачи которых по обработке данных осуществляются на серверах, к которым подсоединено приложение и компьютер.

*Толстый клиент* - приложение, обеспечивающее полное функционирование вне зависимости от сервера. Расчёты, обработка совершается на устройстве пользователя.
## 25. Опишите сходства и различия "толстого" и "тонкого" клиентов.
+ Тонкий клиент не выдвигает особенных требований к линии связи, поскольку обмен данных с сервером происходит в небольшом объёме.
+ Чтобы установаить, загрузить и настроить обновления для толстой версии, понадобится вызвать квалифицированного специалиста. Это связано с тем, что пакет подразумевает использование большого объем ПО.
+ Пакет, работающий в тонком режиме, имеет меньше требований к линии связи, что совсем не противоречит полному использованию системы. Но если несколько сотрудников в одно и то же время будут потреблять резервы сервера, могут появиться проблемы в системе.
+ Для обновления тонкого приложения не требуется вмешательства сотрудника, она обновляется в автоматическом режиме. Для толстой версии их придется скачать с официальной страницы.
## 26. Что такое архитектура программного обеспечения?
Совокупность важнейших решений об организации программной системы. Архитектура включает:
+ выбор структурных элементов и их интерфейсов, с помощью которых составлена система, а также их поведения в рамках сотрудничества структурных элементов;
+ соединение выбранных элементов структуры и поведения во всё более крупные системы;
+ архитектурный стиль, который направляет всю организацию — все элементы, их интерфейсы, их сотрудничество и их соединение.
## 27. Что включает в себя понятие архитектуры программного обеспечения?
*Архитектура программного обеспечения* - совокупность важнейших решений об организации программной системы.
## 28. Что такое паттерн проектирования?
Повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста.
## 29. Опишите кратко паттерн проектирования MVC.
Model-View-Controller - схема разделения данных приложения и управляющей логики на три отдельных компонента: модель, представление и контроллер — таким образом, что модификация каждого компонента может осуществляться независимо.
+ Модель предоставляет данные и реагирует на команды контроллера, изменяя своё состояние.
+ Представление отвечает за отображение данных модели пользователю, реагируя на изменения модели.
+ Контроллер интерпретирует действия пользователя, оповещая модель о необходимости изменений.
## 30. Опишите признаки использования подхода MVC.
* Контроллер определяет,	 какое представление должно быть отображено в требуемый момент.
## 31. Опишите кратко паттерн проектирования MVP.
Model-View-Presenter — шаблон проектирования, производный от MVC, который используется в основном для построения пользовательского интерфейса, был разработан для облегчения автоматического модульного тестирования и улучшения разделения ответственности в презентационной логике (отделения логики от отображения):
+ Модель — данные для отображения;
+ Вид — реализует отображение данных (из Модели), обращается к Presenter за обновлениями, перенаправляет события от пользователя в Presenter;
+ Представитель — реализует взаимодействие между Моделью и Видом и содержит в себе всю логику представления данных о предметной области; при необходимости получает данные из хранилища и преобразует для отображения во View.
## 32. Опишите признаки использования подхода MVP.
* двухсторонняя коммуникация с представлением;
* представление взаимодействует на прямую с presenter'ом путём вызова соответствующих функций или событий;
* одному presenter'у соответствует одно отображение.
## 33. Опишите кратко паттерн проектирования MVVM.
MVVM состоит из трех компонентов: модели (Model), модели представления (ViewModel) и представления (View).
+ Модель описывает используемые в приложении данные. Модели могут содержать логику, непосредственно связанную этими данными, например, логику валидации свойств модели. В то же время модель не должна содержать никакой логики, связанной с отображением данных и взаимодействием с визуальными элементами управления/
+ View определяет визуальный интерфейс, через который пользователь взаимодействует с приложением. Применительно к WPF представление - это код в xaml, который определяет интерфейс в виде кнопок, текстовых полей и прочих визуальных элементов.
+ ViewModel содержит логику по получению данных из модели, которые потом передаются в представление. И также ViewModel определяет логику по обновлению данных в модели.
## 34. Опишите признаки использования подхода MVVM.
* Двухсторонняя коммуникация с представлением;
* View-model не имеет ссылки на интерфейс представления;
* Изменение состояния view-model'и автоматически изменяет состояние представления и наоборот;
* Одному экземпляру view-model'и соответствует одно представление.
## 35. Кратко опишите историю развития языка программирования PHP.
- 1994 - датский программист Расмус Лердорф создал набор скриптов на Perl, называемый Personal HomePage tools;
- 1995 - открытие исходного кода;
- 1997 - PHP 2.0 обработчик написанный на C;
- PHP hypertext preprocessor
- 2000 - PHP 4.0
- 2005 - PHP 5.0
- 2015 - PHP
- 2020 - PHP
## 36. Опишите что такое файл php.ini в рамках языка программирования PHP.
Файл конфигурации считывается при запуске PHP. Для версий серверных модулей PHP это происходит только один раз при запуске веб-сервера. Файл `php.ini` имеет такие правила синтаксиса `директива = значение`. Если вы хотите добавлять комментарии (например, в которых указываете на что влияет данная настройка), то делайте после точки с запятой (всё, что идёт после этого знака не учитывается как команда).
Пример `php.ini`:
```ini
PHPengine = On ; Работа PHP-скриптов включена.

short_open_tag = On ; Разрешает упрощенно обрамлять PHP-код тагами <?. Если будет значение Off, то PHP-код обрамлять в традиционные <?php.

asp_tags = On ; Включает возможность выделять PHP-код, как это делается в ASP - <% %>

Precision = 12 ; Указывает сколько цифр будет после запятой, у чисел с плавающей точкой.

output_buffering = 4096 ; Автоматически будет включена буферизация вывода, с размером буфера указанным после "равно".

safe_mode = On ; Безопасный режим.
```
## 38. Опишите как написать простую программу на PHP.
Любая программа на PHP начинается с открывающего тега `<?php`. Программа может заканчиваться закрывающим тегом `?>`. После каждого выражения обязательна точка с запятой. Таким образом простейшую программу на PHP можно описать так:
```php
<?php
	echo "Hello world!";
```
## 39. Опишите комбинирование PHP и HTML.
Код PHP может использоваться в файлах HTML. Для этого в любом месте файла нужно прописать открывающий тег `<?php` и закрывающий тег `?>`.
## 40. Опишите основные правила, связанные с переменными в PHP
Для осуществления операций с переменными существуют различные группы операторов. Оператором называется нечто, состоящее из одного или более выражений, которое можно вычислить как новое значение (таким образом, вся конструкция может рассматриваться как выражение). Отсюда следует, что функции или любые другие конструкции, которые возвращают значение (например, `print()`) являются операторами, в отличие от всех остальных языковых конструкций (например, `echo()`), которые ничего не возвращают.
## 41. Опишите основные типы данных в PHP.
PHP является языком с динамической типизацией. Это значит, что тип данных переменной выводится во время выполнения, и в отличии от ряда других языков программирования в PHP не надо указывать перед переменной тип данных.
В PHP есть десять базовых типов данных:
+ bool (логический тип)
+ int (целые числа)
+ float (числа с плавующей запятой)
+ string (строки)
+ array (массивы)
+ object (объекты)
+ callable (функции)
+ mixed (любой тип)
+ resource (ресурсы)
+ null (отсутствие значения)
## 42. Опишите основные функции для работы с переменными на уровне типов.
+ `empty` - проверяет, пустая ли переменная;
+ `gettype` - возвращает тип переменной;
+ `is_<data type>` - проверяет переменную на соответствие типу;
+ `isset` - проверяет, было ли установлено значение переменной;
+ `print_r` - выводит информацию о переменной в удобном виде;
+ `settype` - задаёт тип переменной;
+ `unset` - удаляет перменную.
## 43. Опишите что такое и как используются предопределённые переменные в PHP
...
## 44. Опишите что такое переменные переменных и приведите пример их использования.
Иногда бывает удобно иметь переменными имена переменных. То есть, имя переменной, которое может быть определено и изменено динамически. Переменная переменной берёт значение переменной и рассматривает его как имя переменной. В вышеприведённом примере может быть использовано как имя переменной при помощи двух знаков доллара:
```php
<?php
	$$a = 'world';
```
Но переменные переменных не могут использоваться с суперглобальными массивами PHP. Переменная `$this` также является особой, на неё нельзя ссылаться динамически.
## 45. Что такое выражение и приведите примеры выражений на PHP.
Выражения - самые важные строительные элементы PHP. Почти всё, что вы пишете в PHP, является выражением. Самое простое и точное определение выражения - "все что угодно, имеющее значение".
Основными формами выражений являются константы и переменные. Если вы записываете `$a = 5`, вы присваиваете `5` переменной `$a`. `5`, очевидно, имеет значение 5 или, другими словами, `5` это выражение со значением 5.
## 46. Что такое оператор в рамках языка программирования и кратко опишите основных оераторов, реализовах в PHP.
Оператором называется нечто, принимающее одно или более значений (или выражений, если говорить на жаргоне программирования), и вычисляющее новое значение (таким образом, вся конструкция может рассматриваться как выражение).

Операторы в PHP можно сгруппировать по количеству принимаемых ими значений. Унарные операторы принимают только одно значение, например, `!` (оператор логического отрицания) или `++` (инкремент). Бинарные операторы принимают два значения; это, например, знакомые всем арифметические операторы `+` (плюс) и `-` (минус), большинство поддерживаемых в PHP операторов входят именно в эту категорию. Ну и, наконец, есть всего один тернарный оператор, `? :`, принимающий три значения, обычно его так и называют - "тернарный оператор".
## 47. Опишите особенности оператора присваивания в PHP.
Базовый оператор присваивания обозначается как `=`. Оператор присваивания означает, что левый операнд получает значение правого выражения. Результатом выполнения оператора присваивания является само присвоенное значение. Таким образом, результат выполнения `$a = 3` будет равен 3.
```php
	$a = ($b = 4) + 5; // $a теперь равно 9, а $b было присвоено 4.
```
В дополнение к базовому оператору присваивания имеются "комбинированные операторы" для всех бинарных арифметических операций, операций объединения массивов и строковых операций, которые позволяют использовать некоторое значение в выражении, а затем установить его как результат данного выражения:
+ `+=`;
+ `-=`;
+ `*=`;
+ `.=`;
и т.д.
## 48. Опишите особенности операторов сравнения в PHP.
Операторы сравнения, позволяют сравнивать между собой два значения.
+ `==` (равно) возвращает `true`, если `$a` равно `$b` после преобразования типов;
+ `===` (тождественно равно);
+ `!=`;
+ `!==`;
+ `<`;
+ `>`;
+ `<=`;
+ `>=`;
+ `<=>` ("космический корабль", число типа `int` меньше, больше или равное нулю, когда `$a` соответственно меньше, больше или равно `$b`).
## 49. Опишите особенности операторов, работающих с массивами в PHP.
+ `+` - объединение массивов;
+ `==` - `true`, если массивы содержат одинаковый пары ключ-значение;
+ `!=`;
+ `!==`.
## 50. Кратко опишите основные управляющие конструкции в PHP.
Любой сценарий PHP состоит из последовательности инструкций. Инструкцией может быть присваивание, вызов функции, повтор кода (цикл), сравнение, или даже инструкция, которая ничего не делает (пустой оператор). После инструкции обычно ставится точка с запятой. Кроме того, инструкции могут быть объединены в блоки заключением их в фигурные скобки. Блок инструкций также сам по себе является инструкцией. В этом разделе описываются различные типы инструкций.
+ `if`

	Конструкция `if` является одной из наиболее важных во многих языках программирования, в том числе и PHP. Она предоставляет возможность условного выполнения фрагментов кода. Выражение вычисляется в булево значение. Если выражение принимает значение `true`, PHP выполнит инструкцию, а если оно принимает значение `false` - проигнорирует;
+ `else`

	Часто необходимо выполнить одно выражение, если определённое условие верно, и другое выражение, если условие не верно. Именно для этого `else` и используется. `else` расширяет оператор `if`, чтобы выполнить выражение, в случае, если условие в операторе `if` равно `false`. Выражение `else` выполняется только, если выражение `if` вычисляется как `false`, и если нет других любых выражений `elseif`, или если они все равны `false`;
+ `elseif`

	Конструкция `elseif` - сочетание `if` и `else`. Аналогично `else`, она расширяет оператор `if` для выполнения различных выражений в случае, когда условие начального оператора `if` эквивалентно `false`. Однако, в отличие от `else`, выполнение альтернативного выражения произойдёт только тогда, когда условие оператора `elseif` будет являться равным `true`;
## 51. Кратко опишите циклы в PHP, приведите примеры.
+ `for`

	Синтаксис цикла:
	```php
	for (expr1; expr2; expr3)
		statement
	```
	+ Первое выражение (`expr1`) всегда выполняется только один раз в начале цикла.
	+ В начале каждой итерации оценивается выражение `expr2`. Если оно принимает значение `true`, то цикл продолжается и выполняются вложенные операторы. Если оно принимает значение `false`, выполнение цикла заканчивается.
	+ В конце каждой итерации выражение `expr3` выполняется.
+ `foreach`

	`foreach` предоставляет простой способ перебора массивов. `foreach` работает только с массивами и объектами, и будет генерировать ошибку при попытке использования с переменными других типов или неинициализированными переменными. Существует два вида синтаксиса:
	```php
	foreach (iterable_expression as $value)
		statement
	foreach (iterable_expression as $key => $value)
		statement
	```
	Первый вариант перебирает массив, задаваемый с помощью `iterable_expression`. На каждой итерации значение текущего элемента присваивается переменной `$value`.

	Второй дополнительно присвоит ключ текущего элемента переменной `$key` на каждой итерации.
+ `while`

	Циклы while являются простейшим видом циклов в PHP
	```php
	while (expr)
		statement
	```
	`while` выполняет вложенные выражения до тех пор, пока выражение в самом `while` является `true`. Значение выражения `expr` проверяется каждый раз перед началом цикла, поэтому даже если значение выражения изменится в процессе выполнения вложенных выражений в цикле, выполнение не прекратится до конца итерации. Если выражение `while` равно `false` с самого начала, вложенные выражения ни разу не будут выполнены.
+ `do-while`

	Цикл `do-while` очень похож на цикл `while`, с тем отличием, что истинность выражения проверяется в конце итерации, а не в начале. Главное отличие от обычного цикла `while` в том, что первая итерация цикла `do-while` выполнится, тогда как она может не выполниться в обычном цикле `while`.
## 52. Опишите использование инструкций break и continue. Приведите примеры.
### `break`
`break` прерывает выполнение текущей структуры `for`, `foreach`, `while`, `do-while` или `switch`.

`break` принимает необязательный числовой аргумент, который сообщает ему выполнение какого количества вложенных структур необходимо прервать. Значение по умолчанию 1, только ближайшая структура будет прервана. Например:
```php
$arr = array('один', 'два', 'три', 'четыре', 'стоп', 'пять');
foreach ($arr as $val) {
	if ($val == 'стоп') {
		break; /* Тут можно было написать 'break 1;'*/
	}
	echo "$val<br>\n";
}
```
### `continue`
`continue` используется внутри циклических структур для пропуска оставшейся части текущей итерации цикла и, при соблюдении условий, начала следующей итерации. `continue` принимает необязательный числовой аргумент, который указывает на скольких уровнях вложенных циклов будет пропущена оставшаяся часть итерации. Значением по умолчанию является `1`, при которой пропускается оставшаяся часть текущего цикла. 
Например:
```php
foreach ($arr as $key => $value) {
	if (!($key % 2)) { // пропуск чётных чисел
		continue;
	}
	do_something_odd($value);
}

$i = 0;
while ($i++ < 5) {
	echo "Снаружи<br />\n";
	while (1) {
		echo "В середине<br />\n";
		while (1) {
			echo "Внутри<br />\n";
			continue 3;
		}
		echo "Это никогда не будет выведено.<br />\n";
	}
	echo "Это тоже.<br />\n";
}
```
## 53. Опишите операторы switch и match. Их сходства и различия.
### `switch`
Оператор `switch` похож на ряд операторов `if` с одинаковым условием. Во многих случаях вам может понадобиться сравнивать одну и ту же переменную (или выражение) с множеством различных значений и выполнять различные участки кода в зависимости от того, какое значение принимает эта переменная (или выражение). Это именно тот случай, для которого удобен оператор `switch`. Конструкция `switch` использует нестрогое сравнение (как если бы был написан оператор `==`).
### `match`
Выражение `match` предназначено для ветвления потока исполнения на основании проверки совпадения значения с заданным условием. Аналогично оператору switch, выражение `match` принимает на вход выражение, которое сравнивается с множеством альтернатив. Но, в отличие от `switch`, оно обрабатывает значение в стиле, больше похожем на тернарный оператор. Также, в отличие от `switch`, используется строгое сравнение (`===`), а не слабое (`==`).
## 54. Опишите операторы include и require. Приведите пример использования.
### `include`
Выражение `include` включает и выполняет указанный файл. Файлы включаются исходя из пути указанного файла, или, если путь не указан, используется путь, указанный в директиве `include_path`. Если файл не найден в `include_path`, `include` попытается проверить директорию, в которой находится текущий включающий скрипт и текущую рабочую директорию перед тем, как выдать ошибку.

Если включение происходит внутри функции включающего файла, тогда весь код, содержащийся во включаемом файле, будет вести себя так, как будто он был определён внутри этой функции. То есть, он будет в той же области видимости переменных этой функции.
Пример:
```php
// vars.php
$color = 'зелёное';
$fruit = 'яблоко';

// test.php
echo "Одно $color $fruit"; // Одно
include 'vars.php';
echo "Одно $color $fruit"; // Одно зелёное яблоко
```
### `require`
`require` аналогично `include`, за исключением того, что в случае возникновения ошибки он также выдаст фатальную ошибку уровня `E_COMPILE_ERROR`. Другими словами, он остановит выполнение скрипта, тогда как `include` только выдал бы предупреждение `E_WARNING`, которое позволило бы скрипту продолжить выполнение.
## 55. Опишите использование альтернативного синтаксиса управляющих структур.
PHP предлагает альтернативный синтаксис для некоторых его управляющих структур, а именно: `if`, `while`, `for`, `foreach` и `switch`. В каждом случае основной формой альтернативного синтаксиса является изменение открывающей фигурной скобки на двоеточие, а закрывающей скобки на `endif`, `endwhile`, `endfor`, `endforeach` или `endswitch`.
## 56. Опишите синтаксис описания функции.
```php
function foo($arg_1, $arg_2, /* ..., */ $arg_n) {
	echo 'Пример функции.\n';
	return $retval;
}
```
## 57. Опишите особенности вопроса области видимости в PHP.
### Область видимости переменной.
Область видимости переменной - это контекст, в котором эта переменная определена. В большинстве случаев все переменные PHP имеют только одну область видимости. Эта единая область видимости охватывает также включаемые (`include`) и требуемые (`require`) файлы.

Переменные в теле функции будут видны только в теле самой функции. При вызове такой переменной будет синтаксическая ошибка, если не указано ключевой слово `global`.

Другой важной особенностью области видимости переменной является статическая переменная. Статическая переменная существует только в локальной области видимости функции, но не теряет своего значения, когда выполнение программы выходит из этой области видимости.
### Область видимости свойства
Свойства класса должны быть определены через модификаторы `public`, `private` или `protected`. Если же свойство определено с помощью `var`, то оно будет объявлено общедоступным свойством.
### Область видимости метода
Методы класса могут быть определены как `public`, `private` или `protected`. Методы, объявленные без указания области видимости, определяются как `public`.
### Область видимости констант
Начиная с PHP 7.1.0, константы класса могут быть определены как `public`, `private` или `protected`. Константы, объявленные без указания области видимости, определяются как `public`.
## 58. Опишите особенности приоритетности операторов в PHP.
Приоритет оператора определяет, насколько "тесно" он связывает между собой два выражения. Если операторы имеют равный приоритет, то будут ли они выполняться справа налево или слева направо определяется их ассоциативностью.
Ассоциативность|Оператор
-|-
(н/а)|`clone new`
правая|`**`
(н/а)|`+` `-` `++` `--` `~` `(int)` `(float)` `(string)` `(array)` `(object)` `(bool)` `@`
(н/а)|`!`
левая|`*` `/` `%`
левая|`+` `-` `.`
левая|`<<` `>>`
левая|`.`
неассоциативна|`<` `<=` `>` `>=`
неассоциативна|`==` `!=` `===` `!==` `<>` `<=>`
левая|`&`
левая|`^`
левая|`|`
левая|`&&`
левая|`||`
правая|`??`
неассоциативна|`? :` тернарный оператор (лево-ассоциативный до PHP 8.0.0)
правая|`=` `+=` `-=` `*=` `**=` `/=` `.=` `%=` `&=` `|=` `^=` `<<=` `>>=` `??=`
левая|`and`
левая|`xor`
левая|`or`
## 59. Опишите реализацию конкатенации строк в PHP.
В PHP есть два оператора для работы со строками. Первый - оператор конкатенации (`.`), который возвращает строку, представляющую собой соединение левого и правого аргумента. Второй - оператор присваивания с конкатенацией (`.=`), который присоединяет правый аргумент к левому.
```php
$a = 'Привет, ';
$b = $a.'Мир!'; // $b теперь содержит строку "Привет, Мир!"

$a = 'Привет, ';
$a .= 'Мир!'; // $a теперь содержит строку "Привет, Мир!"
```
## 60. Опишите принцип разделения инструкций в PHP.
PHP требует окончания инструкций точкой запятой в конце каждой инструкции. Закрывающий тег блока автоматически применяет точку с запятой; т.е. нет необходимости ставить точку с запятой в конце последней строки блока с кодом. Закрывающий тег блока "поглотит" немедленно следующий за ним переход на новую строку, если таковой будет обнаружен. Закрывающий тег PHP-блока в конце файла не является обязательным, и в некоторых случаях его опускание довольно полезно, например, при использовании `include` или `require`, так, что нежелательные пробелы не останутся в конце файла и вы всё ещё сможете добавить HTTP-заголовки после подключения к ответу сервера.
```php
<?php echo "Какой-то текст"; ?>
Нет новой строки
<?= "А сейчас, новая строка" ?>

<?php
	echo 'Это тест';
?>

<?php echo 'Это тест' ?>

<?php echo 'Мы опустили последний закрывающий тег';
```
## 61. Опишите особенности типа данных массив в PHP.
Массив в PHP - это упорядоченное отображение, которое устанавливает соответствие между значением и ключом. Этот тип оптимизирован в нескольких направлениях, поэтому его можно использовать как собственно массив, список (вектор), хеш-таблицу (являющуюся реализацией карты), словарь, коллекцию, стек, очередь и т.д. Так как значением массива может быть другой массив PHP, можно также создавать деревья и многомерные массивы.

Массив (тип `array`) может быть создан языковой конструкцией `array()`. В качестве параметров она принимает любое количество разделённых запятыми пар `key => value` (ключ - значение).
```php
array(
	key => value,
	key2 => value2,
	key3 => value3,
	...
)
```
Ключ может быть либо типа `int`, либо типа `string`. Значение может быть любого типа.

Дополнительно с ключом `key` будут сделаны следующие преобразования:
+ Строки, содержащие целое число (исключая случаи, когда число предваряется знаком `+`) будут преобразованы к типу `int`. Например, ключ со значением "8" будет в действительности сохранён со значением 8. С другой стороны, значение `08` не будет преобразовано, так как оно не является корректным десятичным целым.
+ Числа с плавающей точкой также будут преобразованы к типу `int`, то есть дробная часть будет отброшена. Например, ключ со значением 8.7 будет в действительности сохранён со значением 8.
+ Тип `bool` также преобразовываются к типу `int`. Например, ключ со значением `true` будет сохранён со значением `1` и ключ со значением `false` будет сохранён со значением `0`.
+ Тип `null` будет преобразован к пустой строке. Например, ключ со значением `null` будет в действительности сохранён со значением `""`.
+ Массивы и объекты не могут использоваться в качестве ключей. При подобном использовании будет генерироваться предупреждение: Недопустимый тип смещения (Illegal offset type).
+ Если несколько элементов в объявлении массива используют одинаковый ключ, то только последний будет использоваться, а все другие будут перезаписаны.
+ Параметр ключа является необязательным. Если он не указан, PHP будет использовать предыдущее наибольшее значение ключа типа `int`, увеличенное на `1`.
+ Возможно указать ключ только для некоторых элементов и пропустить для других.
Существующий массив может быть изменён путём явной установкой значений в нём. Это выполняется присвоением значений массиву с указанием в скобках ключа. Кроме того, ключ можно опустить, в результате получится пустая пара скобок (`[]`).
```php
$arr[key] = value;
$arr[] = value;
// key может быть int или string
// value может быть любым значением любого типа
```
Если массив `$arr` ещё не существует или для него задано значение `null` или `false`, он будет создан. Таким образом, это ещё один способ определить массив.

Для изменения определённого значения просто присвойте новое значение элементу, используя его ключ. Если вы хотите удалить пару ключ/значение, вам необходимо использовать функцию `unset()`.
## 62. Опишите использование фигурных скобок при форматировании строк в PHP.
При обработке переменных в строку существует два типа синтаксиса: простой и сложный. Простой синтаксис более лёгок и удобен. Он даёт возможность обработки переменной, значения массива или свойства объекта с минимумом усилий.

Сложный синтаксис может быть определён по фигурным скобкам, окружающим выражение.
### Простой синтаксис
Если интерпретатор встречает знак доллара (`$`), он захватывает так много символов, сколько возможно, чтобы сформировать правильное имя переменной. Если вы хотите точно определить конец имени, заключайте имя переменной в фигурные скобки.
```php
$juice = "apple";
echo "He drank some $juice juice.";

// Некорректно. 's' - верный символ для имени переменной, но переменная имеет имя $juice.
echo "He drank some juice made of $juices.";

// Корректно. Строго указан конец имени переменной с помощью скобок:
echo "He drank some juice made of ${juice}s.";
```
### Сложный (фигурный) синтаксис
Любая скалярная переменная, элемент массива или свойство объекта, отображаемое в строку, может быть представлена в строке этим синтаксисом. Выражение записывается так же, как и вне строки, а затем заключается в фигурные скобки. Поскольку `{` не может быть экранирован, этот синтаксис будет распознаваться только когда `$` следует непосредственно за `{`. Используйте `{\$`, чтобы напечатать `{$`:
```php
$great = 'здорово';

// Не работает, выводит: Это { здорово}
echo "Это { $great}";

// Работает, выводит: Это здорово
echo "Это {$great}";

// Работает
echo "Этот квадрат шириной {$square->width}00 сантиметров.";

// Работает, ключи, заключённые в кавычки, работают только с синтаксисом фигурных скобок
echo "Это работает: {$arr['key']}";

// Работает
echo "Это работает: {$arr[4][3]}";
```
До PHP 8.0.0 для доступа к символу в строке также можно было использовать фигурные скобки, например, `$str{42}`. Синтаксис фигурных скобок устарел в PHP 7.4.0 и больше не поддерживается в PHP 8.0.0.
## 63. Опишите особенности приоритетности операторов в PHP. Что такое ассоциативность операторов?
См. 58
*Ассоциативность* — свойство операций, позволяющее восстановить последовательность их выполнения при отсутствии явных указаний на очерёдность при равном приоритете; при этом различается левая ассоциативность, при которой вычисление выражения происходит слева направо, и правая ассоциативность — справа налево. Соответствующие операторы называют левоассоциативными и правоассоциативными.
## 64. Опишите особенности арифметических операторов в PHP. Как работает автоматическое пеобразование из строки в число и когда?
Пример|Название|Результат
-|-|-
`+$a`|Идентичность|Конвертация `$a` в `int` или `float`, что более подходит.
`-$a`|Отрицание|Смена знака.
`$a + $b`|Сложение|Сумма.
`$a - $b`|Вычитание|Разность.
`$a * $b`|Умножение|Произведение.
`$a / $b`|Деление|Частное от деления.
`$a % $b`|Деление по модулю|Целочисленный остаток от деления.
`$a ** $b`|Возведение в степень|Возведение `$a` в степень `$b`.
Операция деления (`/`) возвращает число с плавающей точкой, кроме случая, когда оба значения являются целыми числами (или строками, которые преобразуются в целые числа), которые делятся нацело - в этом случае возвращается целое значение.

При делении по модулю операнды преобразуются в целые числа (путём удаления дробной части) до начала операции.

Результат операции остатка от деления `%` будет иметь тот же знак, что и делимое — то есть, результат `$a % $b` будет иметь тот же знак, что и `$a`.

Примером автоматического преобразования типа является оператор умножения `*`. Если какой-либо из операндов является `float`, то все операнды интерпретируются как `float`, и результатом также будет `float`. В противном случае операнды будут интерпретироваться как `int`, и результат также будет `int`. Обратите внимание, что это НЕ меняет типы самих операндов; меняется только то, как они вычисляются и сам тип выражения
```php
$foo = "1"; // $foo - это строка (ASCII-код 49)
$foo *= 2; // $foo теперь целое число (2)
$foo = $foo * 1.3; // $foo теперь число с плавающей точкой (2.6)
$foo = 5 * "10 Little Piggies"; // $foo - это целое число (50)
$foo = 5 * "10 Small Pigs"; // $foo - это целое число (50)
```
## 65. Что такое веб-сервер?
*Веб-сервер* — сервер, принимающий HTTP-запросы от клиентов, обычно веб-браузеров, и выдающий им HTTP-ответы, как правило, вместе с HTML-страницей, изображением, файлом, медиа-потоком или другими данными. Также это компьютерная программа, которая принимает запрос данных и отправляет указанные документы. Веб-сервером может быть компьютер, на котором хранится онлайн-контент.
## 66. Что такое сервер приложения и чем он отличается от веб-сервера?
Веб-сервер и сервер приложений — это разновидности серверов, которые используются для доставки сайтов, и, следовательно, последний имеет дело с операциями приложений, выполняемыми между пользователями и внутренними бизнес-приложениями организации.
## 67. Кратко опишите историю развития интернета в рамках развития веб-серверов.
6 августа 1991 года Тим Бернерс-Ли добился весомого результата в создании идеи глобальной сети под названием "World Wide Web" (WWW), без которой миллиарды людей даже не знали бы об интернете. Сайты представляли собой простой HTML-документ, для обмена такими документами по сети была разработан протокол HTTP. Он реализован по клиент-серверной технологии и работает по принципу запрос-ответ без сохранения состояния. Целью запроса служит некий ресурс, который определяется URI, HTTP использует одну из разновидностей URI.
## 68. Кратко опишите протокол HTTP.
HTTP — широко распространённый протокол передачи данных, изначально предназначенный для передачи гипертекстовых документов (то есть документов, которые могут содержать ссылки, позволяющие организовать переход к другим документам). Протокол HTTP предполагает использование клиент-серверной структуры передачи данных. Клиентское приложение формирует запрос и отправляет его на сервер, после чего серверное программное обеспечение обрабатывает данный запрос, формирует ответ и передаёт его обратно клиенту. После этого клиентское приложение может продолжить отправлять другие запросы, которые будут обработаны аналогичным образом.
## 69. Опишите механизм взаимодействия HTTP-сервера, HTTP-клиента и пользователя.
Клиент и сервер взаимодействую друг с другом в сети Интернет или в любой другой компьютерной сети при помощи различных сетевых протоколов, например, IP, HTTP, FTP и другие. Протоколов на самом деле очень много и каждый протокол позволяет оказывать ту или иную услугу. Сообщения, которые посылают клиенты получили названия HTTP запросы. Запросы имеют специальные методы, которые говорят серверу о том, как обрабатывать сообщение. А сообщения, которые посылает сервер получили название HTTP ответы, они содержат помимо полезной информации ещё и специальные коды состояния, которые позволяют браузеру узнать то, как сервер понял его запрос.
## 70. Опишите цели и задачи веб-сервера.
Основная задача веб-сервера - приём HTTP-запросов, их обработка и выдача HTTP-ответов. Также к задачам веб-серверов относятся создание журналов ошибок и обращений к файлам (логов), аутентификация и авторизация пользователей, использование настроек для обработки файлов.
## 71. Опишите технологию SSI.
SSI (Server Side Includes — включения на стороне сервера) — несложный язык для динамической «сборки» веб-страниц на сервере из отдельных составных частей и выдачи клиенту полученного HTML-документа. Реализован в веб-сервере Apache при помощи модуля mod_include. Включённая в настройках по умолчанию веб-сервера возможность позволяет подключать HTML-файлы, поэтому для использования инструкций файл должен оканчиваться расширением `.shtml`, `.stm` или `.shtm`.
## 72. Что такое система управления контентом?
CMS (Content Management System) — это система управления, движок, платформа или конструктор, который позволяет управлять содержимым сайта.
## 73. Верно ли, что сервер приложения умеет работать с протоколом HTTP?
Нет, так как это задача веб-сервера. Чтобы обеспечить их взаимодействие был разработан общий интерфейс шлюза - CGI (Common Gateway Interface).
## 74. Что такое CGI?
CGI (Common Gateway Interface — «интерфейс общего шлюза») — стандарт интерфейса, используемого внешней программой для связи с веб-сервером. Сервер-приложений не работает с HTTP и не обрабатывает их действия, т.к. это задача веб-сервера. Чтобы обеспечить их взаимодействие, необходимо было разработать общий интерфейс шлюза. Это не программа и не протокол, это интерфейс, т.е. совокупность способов взаимодействия между приложениями. Для передачи используются стандартные потоки ввода-вывода, от веб-сервера к CGI-приложению, например, данные передаются через поток `stdin`, а обратно принимаются через поток `stdout`. Для передачи сообщений об ошибках используется поток `stderror`.
## 75. Как работает система с использованием интерфейс шлюза - CGI?
Обобщённый алгоритм работы через CGI можно представить в следующем виде:
1. Клиент запрашивает CGI-приложение по его URI.
2. Веб-сервер принимает запрос и устанавливает переменные окружения, через них приложению передаются данные и служебная информация.
3. Веб-сервер перенаправляет запросы через стандартный поток ввода (`stdin`) на вход вызываемой программы.
4. CGI-приложение выполняет все необходимые операции и формирует результаты в виде HTML.
5. Сформированный гипертекст возвращается веб-серверу через стандартный поток вывода (`stdout`). Сообщения об ошибках передаются через `stderr`.
6. Веб-сервер передает результаты запроса клиенту.
## 76. Назовите достоинства и недостатки CGI.
- CGI не налагает особых условий на платформу и web-сервер, поэтому работает на всех популярных платформах и web-серверах. Также технология не привязана к конкретному языку программирования и может быть использована на любом языке, работающем со стандартными потоками ввода/вывода.
- Производительность CGI-программ не высока. Основной причиной этого является то, что при очередном обращении к серверу для работы CGI–программы создаётся отдельный процесс, что требует большого количества системных ресурсов.
- Встроенных средств масштабируемости технология не предусматривает.
- CGI-программа представляет из себя готовый к исполнению файл, что препятствует легкому расширению системы.
## 77. Что такое FastCGI?
Интерфейс FastCGI — клиент-серверный протокол взаимодействия веб-сервера и приложения, является дальнейшим развитием технологии CGI. По сравнению с CGI является более производительным и безопасным.
## 78. Назовите основные отличия CGI от FastCGI.
FastCGI - это тот же CGI, но отличается от него тем, что позволяет Apache не запускать для каждого скрипта отдельный процесс, а запустить один или несколько процессов и отдавать скрипты ему, получать от него ответ. Это немного производительнее, чем CGI, засчёт того, что операции создания процессов для ОС считаются довольно ресурсоёмкими. Но в этой схеме всё ещё присутсвует Apache. FastCGI без Apache в данном случае работать не может, это все равно модуль mod_fastcgi.
## 79. Что такое менеджер процессов?
Менеджер процессов служит для распределения нагрузки. Процессы могут быть как частью веб-сервера, так и отдельным приложением.
## 80. Что такое PHP-FPM?
PHP-FPM — это альтернативная реализация PHP FastCGI с несколькими дополнительными возможностями, которые обычно используются для высоконагруженных сайтов:
+ Продвинутое управление процессами с корректной процедурой остановки и запуска;
+ Возможность запуска воркеров с разными uid/gid/chroot/окружением, а также запуска на различных портах с использованием разных `php.ini` (замещение safe_mode);
+ логирование стандартных потоков вывода (`stdout`) и ошибок (`stderr`);
+ аварийный перезапуск в случае внезапного разрушения opcode-кеша;
+ поддержка ускоренной загрузки (accelerated upload);
+ "slowlog" - логирование необычно медленно выполняющихся скриптов (не только их имена, но также и их трассировки. Это достигается с помощью ptrace и других подобных утилит для чтения данных исполнения удалённых процессов);
+ `fastcgi_finish_request()` - специальная функция для завершения запроса и сброса всех буферов данных, причём процесс может продолжать выполнение каких-либо длительных действий (конвертирование видео, обработка статистики и т.п.);
+ Динамическое/статическое порождение дочерних процессов;
+ Базовая информация о статусе SAPI (аналогично Apache mod_status);
+ Конфигурационный файл, основанный на `php.ini`.
## 81. Что такое Spawn-fcgi?
spawn-fcgi — одна из составных частей проекта Lighttpd. spawn-fcgi используется для запуска удаленных и локальных FastCGI процессов. Плюсы spawn-fcgi:
+ Разделение привилегий без необходимости suid-исполняемого файла или запуска сервера с привилегиями root;
+ Возможность отдельного перезапуска как FastCGI-приложения, так и сервера;
+ Возможность запуска в изолированном окружении (chroot);
+ FastCGI-приложение не зависит от используемого веб-сервера, что даёт возможность, использовать различные веб-сервера.
## 82. Что такое Lighttpd?
lighttpd — веб-сервер, разрабатываемый с расчётом на скорость и защищённость, а также соответствие стандартам. В lighttpd есть поддержка сжатия отдаваемого содержимого «на лету», HTTP-аутентификации, перезаписи URL, SSL и автоматической балансировки нагрузки (нагрузка может автоматически распределяться по нескольким запущенным серверам lighttpd). Веб-сервер также поддерживает интерфейсы CGI, SCGI, FastCGI.
## 83. Что такое chroot-окружение?
Chroot-окружение – это системный вызов, который временно перемещает корневой каталог в новую папку. Как правило, root каталог находится в "/". Но при помощи chroot можно задать другой каталог, который будет служить как корневой каталог в окружении chroot.
## 84. Опишите механизм взаимодействия серверов с использованием FastCGI.
FastCGI устраняет основную проблему CGI: повторный запуск процесса приложения на каждый запрос. FastCGI-процессы запущены постоянно, чтобы экономить время и ресурсы. Для передачи данных вместо стандартных потоков (`stdin`, `stdout`, `stderror`), используются UNIX-сокеты для работы в пределах одной ОС, или TCP/IP, что позволяет размещать веб-сервер и сервера приложений на разных хостах, таким образом обеспечивая масштабирование и высокую доступность системы. Также на одном ПК можно запустить сразу несколько FastCGI-процессов, которые могут обрабатывать запросы параллельно, либо иметь различные настройки и версии.
## 85. Опишите процесс выбора встроенного или внешнего менеджера процессов.
Apache использует внутренний менеджер процессов, nginx - внешний, например php-fpm или spawn-fsgi. Внешний менеджеры позволяют изолировать каждый FastCGI-процесс в своём окружении. Сошу окружение - это системный вызов, который временно перемещает корневой каталог в новую временную папку с помощью chroot.
## 86. Что такое интерфейс шлюза?
...
## 87. Что такое SCGI?
Simple Common Gateway Interface (SCGI) — протокол по взаимодействию приложений с веб-серверами, разработанный как альтернатива Common Gateway Interface. Он похож на FastCGI, но проще в реализации.
## 88. Что такое PCGI?
PCGI (Perl Common Gateway Interface) — библиотека к языку программирования Perl для работы с интерфейсом CGI (Common Gateway Interface).
## 89. Что такое PSGI?
PSGI, или Perl Web Server Gateway Interface - спецификация, предназначенная для отделения среды веб-сервера от кода веб-фреймворка. PSGI не является программным интерфейсом (API) для веб-приложений.
## 90. Что такое WSGI?
WSGI — стандарт взаимодействия между Python-программой, выполняющейся на стороне сервера, и самим веб-сервером, например Apache.
## 91. Опишите механизм взаимодействия серверов Apache и PHP.
В простейшем случае при поступлении HTTP-запроса веб-сервер должен считать содержимое запрашиваемого файла с жёсткого диска, упаковать его содержимое в HTTP-ответ и отправить клиенту. В случае если требуемый файл не найден на жёстком диске, то веб-сервер сгенерирует ошибку с указанием статусного кода 404 и отправит это сообщение клиенту. Такой вариант работы веб-сервера принято называть статическими сайтами. В этом случае на стороне сервера не запускается никакой программный код, кроме программного кода самого веб-сервера.
## 92. Опишите преимущества веб-сервера Apache.
- Доступность.

	Это программное обеспечение с открытым исходным кодом. Значит, его может бесплатно использовать или модифицировать любой желающий. Разработчики по всему миру создают конфигурации и модули веб-сервера для своих специфических нужд. По этой же причине Apache регулярно получает полезные дополнения, расширяющие его базовый функционал.

- Гибкость настройки.

	Apache использует несколько конфигурационных файлов для управления веб-сервером. Это позволяет настроить ПО под узконаправленные задачи.

- Функциональность.

	У Apache динамическая модульная структура. Можно быстро подключать дополнительный функционал в виде скачиваемых модулей, даже без обращения к внешним источникам. Это позволяет решать целый комплекс важнейших задач в области безопасности, кэширования, редактирования URL, распределения нагрузки. Благодаря гибридным модулям MPM, Apache может одинаково успешно обслуживать статический и динамический контент. Есть возможность оперативно отключать ненужные модули и ускорять работу веб-сервера.

- Кроссплатформенность.

	Apache работает как на Windows, так и на всех Unix-подобных системах. Администрирование веб-сервером не имеет серьёзных отличий на разных ОС. Индивидуален только процесс установки и расположение директорий с файлами программы.

- Совместимость.

	Apache работает на базе скриптовых или веб-ориентированных языков (PHP, Python, Tcl, Ruby, Perl, ASP), что делает его совместимым с самым широким спектром баз данных и серверного ПО. Многие веб-приложения и инструменты сразу выходят со средствами запуска из-под Apache в виде PHP-модуля. Веб-сервер, поддерживает технологии FastCGI и CGI, позволяющие пользоваться программными продуктами на объектно-ориентированных языках Java, sh, C, C++.

- Масштабируемость.

	Подходит для веб-ресурсов любого масштаба. Apache хорошо работает как на одностраничном сайте (лендинге), так и на многостраничном сайте с ежедневной аудиторией в десятки тысяч посетителей.

- Поддержка пользователей.

	Apache удерживает первенство популярности среди веб-серверов с 1996 года. За прошедшее время для него создана обширнейшая база документации – как официальной, так и созданной сторонними разработчиками. Готовые, подробно описанные руководства можно найти практически на любой сценарий.
## 93. Опишите недостатки веб-сервера Apache.
- Производительность.

	Скорость обработки запросов Apache несколько ниже, по сравнению со своими конкурентами. Гибкость веб-сервера в некоторых случаях вредит производительности. Например, Apache приходится каждый раз считывать несколько конфигурационных файлов на сервере, затрачивая системные ресурсы и время. Но этот и многие другие факторы можно исправить, отключив ненужные опции. Правда в таком случае функциональность Apache не будет сильно отличаться от других веб-серверов.

- Сложная конфигурация повышает уязвимость.

	Возможность подключать модули в Apache это не всегда преимущество. Чем больше модулей, тем сложнее становятся настройки. Соответственно, больше шансов допустить критические пробелы в контуре безопасности.

- Синтаксис конфигов.

	В файлах с параметрами программы используются разнообразные переменные, поэтому настройка и управление веб-сервером может показаться сложной новичкам. Упростить администрирование Apache можно с помощью бесплатного инструмента Apache GUI.

- Излишний функционал.

	Даже без дополнительных модулей Apache предоставляет пользователям массу возможностей. Правда, большинство использует лишь небольшую часть базового функционала приложения. Поэтому часто после установки приходится тратить время на отключение «лишних» модулей.
## 94. Опишите архитектуру веб-сервера Apache.
Apache состоит из ядра и динамической модульной системы. Параметры системы изменяются с помощью конфигурационных файлов.
### Ядро
Ядро Apache разработано Apache Software Foundation на языке C. Основные функции — обработка конфигурационных файлов, протокол HTTP/HTTPS и загрузка модулей. Ядро может работать без модулей, но будет иметь ограниченный функционал.
### Модульная система
*Модуль* – отдельный файл, подключение которого расширяет изначальный функционал ядра. Они могут включаться в состав ПО при первоначальной установке или подгружаться позже через изменение конфигурационного файла. Большинство из них отвечает за определённый аспект обработки клиентского запроса – поддержку различных языков программирования, безопасность, кэширование, аутентификацию и т.д. Таким образом, большая задача разбивается на несколько фаз, каждую из которых решает отдельный, узкоспециализированный модуль. Для Apache существует больше 500 модулей.
### Конфигурация
Система конфигурации Apache работает на текстовых файлах с прописанными настройками. Она подразделяется на три условных уровня, для каждого из которых имеется свой конфигурационный файл:
- Уровень конфигурации сервера (`httpd.conf`) – основной конфигурационный файл. Действие распространяется на весь механизм веб-сервера.
- Уровень каталога (`.htaccess`) – дополнительный конфигурационный файл. Его директивы охватывают только каталог, где расположен файл, а также вложенные подкаталоги.
- Уровень виртуального хоста (`httpd.conf` или `extra/httpd-vhosts.conf`).

Обычно конфигурационные файлы Apache находятся в папке `conf`, а дополнительные конфигурационные файлы во вложенной в неё папке `extra`. Внести изменения можно как через редактирование самого файла, так и через командную строку.
## 95. Опишите функции ядра веб-сервера Apache.
Основные функции ядра:
- Передача данных по HTTP;
- Обработка файлов;
- Загрузка и поддержка модулей.
## 96. Опишите конфигурацию веб-сервера Apache.
Конфигурацию Apache, можно разделить на три основных уровня:
- Конфигурация сервера;
- Конфигурация виртуального хоста;
- Конфигурация уровней каталога.
## 97. Что такое URI, URL и чем они различаются.
### URI
Uniform Resource Identifier (унифицированный идентификатор ресурса). Это имя и адрес ресурса в сети, включает в себя URL и URN. URI содержит в себе следующие части:
- Схема (scheme) - показывает на то, как обращаться к ресурсу, чаще всего это сетевой протокол (http, ftp, ldap);
- Иерархическая часть (hier-part) - данные, необходимые для идентификации ресурса (например, адрес сайта);
- Запрос (query) - необязательные дополнительные данные ресурса (например, поисковой запрос);
- Фрагмент (fragment) – необязательный компонент для идентификации вторичного ресурса ресурса (например, место на странице).
### URL
Uniform Resource Locator (унифицированный определитель местонахождения ресурса. Это адрес ресурса в сети, определяет местонахождение и способ обращения к нему.
- Протокол, который используется для доступа к ресурсу – http, https, ftp;
- Расположение сервера с использованием IP-адреса или имени домена - например: `wiki.merionet.ru` - это имя домена, `https://192.168.1.17` - ресурс расположен по указанному IP-адресу
- Номер порта на сервере. Например, `http://localhost:8080`, где `8080` - это порт.
- Точное местоположение в структуре каталогов сервера. Например: `https://wiki.merionet.ru/ip-telephoniya/` - это точное местоположение, если пользователь хочет перейти в раздел про телефонию на сайте.
- Необязательный идентификатор фрагмента. Например, `https://www.google.com/search?ei=qw3eqwe12e1w&q=URL`, где `q=URL` - это строка запроса, введённая пользователем.
### Сравнение
URI|URL
-|-
Идентификатор ресурса|Определитель местонахождения
`scheme:[//authority]path[?query][#fragment]`, где `authority = [userinfo@]host[:port]|[protocol]://www.[domain_name]:[port 80]/[path or exaction resource location]?[query]#[fragment]`
Схема может быть любой - протокол, имя или спецификация и так далее|Схема всегда является протоколом, таким как http, https, ftp, LDAP и так далее
Основная цель URI - идентифицировать ресурс и отличить его от других ресурсов, используя местоположение или имя.|Основная цель - получить адрес или местоположение ресурса
Пример: contact: +1 883-345-1111, urn:isbn:1234567890|Пример: `https://wiki.merionet.ru/servernye-resheniya/36/vse-chto-vam-nuzhno-znat-pro-devops/?f=0`
Используется в файлах HTML, XML и библиотек тегов, таких как XSLT и jstl, для идентификации ресурсов и двоичных файлов.|URL используется для поиска только веб-страниц
## 98. Что такое HTTP-запрос?
Задача, которая традиционно решается с помощью протокола HTTP—обмен данными между пользовательским приложением, осуществляющим доступ к веб-ресурсам (обычно это веб-браузер) и веб-сервером. На данный момент именно благодаря протоколу HTTP обеспечивается работа Всемирной паутины.
## 99. Опишите существующие HTTP-запросы.
- GET — получение ресурса
- POST — создание ресурса
- PUT — обновление ресурса
- DELETE — удаление ресурса
## 100. Опишите обработку запроса на PHP. Что нужно использовать, как вычленить праметры запроса?
- Внутри PHP-скрипта имеется несколько способов получения доступа к данным, переданным клиентом по протоколу HTTP. До версии PHP 4.1.0 доступ к таким данным осуществлялся по именам переданных переменных. Таким образом, если, например, было передано `first_name=Nina`, то внутри скрипта появлялась переменная `$first_name` со значением `Nina`. Если требовалось различать, каким методом были переданы данные, то использовались ассоциативные массивы `$HTTP_POST_VARS` и `$HTTP_GET_VARS`, ключами которых являлись имена переданных переменных, а значениями – соответственно значения этих переменных. Таким образом, если пара `first_name = Nina` передана методом GET, то `$HTTP_GET_VARS["first_name"]="Nina"`.
- Использовать в программе имена переданных переменных напрямую небезопасно. Поэтому было решено начиная с PHP 4.1.0 задействовать для обращения к переменным, переданным с помощью HTTP-запросов, специальный массив – `$_REQUEST`. Этот массив содержит данные, переданные методами POST и GET, а также с помощью HTTP cookies. Это суперглобальный ассоциативный массив, т.е. его значения можно получить в любом месте программы, используя в качестве ключа имя соответствующей переменной (элемента формы).
## 101. Опишите создание HTML-форм на PHP.
### Форма
Рассмотрим один типичный пример — форма обратной связи. Для связи пользователей с авторами сайта, как правило, используются формы обратной связи, где человек указывает имя, почту для обратной связи и текст своего сообщения:
```html
<form name="feedback" method="POST" action="form.php">
	<label>Ваше имя: <input type="text" name="name"></label>
	<label>Ваш email: <input type="text" name="email"></label>
	<label>Сообщение: <textarea name="message"></textarea></label>

	<input type="submit" name="send" value="Отправить">
</form>
```
Почти весь приведённый код описывает внешний вид и содержание формы, но следует обратить внимание на два атрибута тега `<form>`, которые нужны для указания на способ обработки данных:
- `method` — этот атрибут используется для определения метода HTTP, который будет использован для передачи данных на сервер.
- `action` — содержит адрес PHP-скрипта, который должен обработать эту форму.
### Обработка формы
Псле отправки формы управление передаётся PHP-скрипту, который должен получить переданные данные, выполнить с ними какие-либо действия и показать результат. Результатом может быть какое-нибудь сообщение об успешном завершении операции, например, «ваши данные успешно отправлены».

В PHP все данные из формы находятся в глобальном ассоциативном массиве `$_POST`. Этот массив всегда будет неявно присутствовать в сценарии, если он был загружен по методу POST. Каждое поле из формы будет находиться в массиве, где ключом будет значение атрибута `name`, а значением содержимое поля. Например, чтобы вывести из формы всю информацию на экран, можно написать такой сценарий:
```php
if (isset($_POST)) {
	echo "Имя: $_POST['name']";
	echo "<br>Email: $_POST['email']";
	echo "<br>Сообщение: $_POST['message']";
}
```
Функция `isset` служит для определения, существует ли переданная ей переменная. Так мы проверяем, что сценарий загружен методом POST, то есть была отправлена форма. Как правило, после обработки формы в PHP, сценарий должен переадресовать пользователя на другую страницу. Это связано с тем, что если форма была отправлена через метод POST, то после обновления страницы данные будут отправлены ещё раз, а это, в большинстве случаев, нежелательное поведение.
## 102. Что такое API?
AI (Application programming interface) — это контракт, который предоставляет программа. Этот контракт устанавливает способ передачи данных программе от другой программы.
## 103. Опишите API как средство интеграции приложений.
AI определяет функциональность, которую предоставляет программа (модуль, библиотека), при этом API позволяет абстрагироваться от того, как именно эта функциональность реализована. Если программу (модуль, библиотеку) рассматривать как чёрный ящик, то API — это множество «ручек», которые доступны пользователю данного ящика, которые он может вертеть и дёргать. Программные компоненты взаимодействуют друг с другом посредством API. При этом обычно компоненты образуют иерархию — высокоуровневые компоненты используют API низкоуровневых компонентов, а те, в свою очередь, используют API ещё более низкоуровневых компонентов.

Важно заметить, что понятие протокола близко по смыслу к понятию API. И то и другое является абстракцией функциональности, только в первом случае речь идёт о передаче данных, а во втором — о построении компьютерных приложений.
## 104. Что такое Web API?
Wb-API - это интерфейс прикладного программирования для веб-сервера или веб-браузера.
## 105. Приведите пример API.
Работа API представляет собой передачу данных по определённому запросу со стороны клиента или другого приложения. Допустим, нужно выудить информацию с существующего сайта и передать её в программу. В браузере будет дан запрос и ожидаться ответ в виде HTML-страницы. Если же используется API в стороннем приложении, то ему может быть достаточно фрагмента данных в формате JSON. На стороне пользователя такая реализация интерфейса будет выглядеть как банальная возможность выполнить действие, связанное с программой А в программе Б, то есть убрать лишний переход в стороннюю программу.
## 106. Что такое REST?
REST (Representational state transfer) – это стиль архитектуры программного обеспечения для распределённых систем, таких как World Wide Web, который, как правило, используется для построения веб-служб. Термин REST был введён в 2000 году Роем Филдингом, одним из авторов HTTP-протокола. Системы, поддерживающие REST, называются RESTful-системами.
## 107. Как организована передача данных в архитектуре REST?
В общем случае это происходит посредством запросов-ответов. Компонент, который отправляет запрос называют *клиентом*; компонент, который обрабатывает запрос и отправляет клиенту ответ, называют *сервером*. Запросы и ответы, чаще всего, отправляются по протоколу HTTP. Как правило сервер — это некое веб-приложение. Клиентом же может быть мобильное приложение, которое запрашивает у сервера данные, либо браузер, который отправляет запросы с веб-страницы на сервер для загрузки данных. Приложение А может запрашивать данные у приложения Б. Тогда А является клиентом по отношению к Б, а Б — сервером по отношению к А. Одновременно с этим, А может обрабатывать запросы от В, Г, Д и т.д. В таком случае, приложение А является одновременно и сервером, и клиентом.
## 108. Как организована работа REST?
REST требует, чтобы клиент сделал запрос на сервер для получения или изменения данных на сервере. Запрос обычно состоит из:
- НТТР-метода, который определяет вид операции;
- заголовка, который позволяет клиенту передавать информацию о запросе;
- пути к ресурсу;
- необязательного тела сообщения, содержащего данные.
## 109. Что такое SOAP?
SOAP — протокол обмена структурированными сообщениями в распределённой вычислительной среде. Первоначально SOAP предназначался в основном для реализации удалённого вызова процедур. Сейчас протокол используется для обмена произвольными сообщениями в формате XML, а не только для вызова процедур.
## 110. Чем SOAP отличается от REST?
- SOAP - простой протокол доступа к объектам, тогда как REST - передача представительного состояния;
- SOAP — это протокол, тогда как REST — это архитектурный паттерн;
- SOAP использует сервисные интерфейсы для предоставления своих функций клиентским приложениям, а REST использует унифицированные локаторы сервисов для доступа к компонентам на аппаратном устройстве;
- SOAP требует большей пропускной способности для его использования, тогда как REST не требует большой пропускной способности.
- SOAP работает только с форматами XML, тогда как REST работает с простым текстом, XML, HTML и JSON.
- SOAP не может использовать REST, тогда как REST может использовать SOAP.
## 111. Для чего нужен SOAP-процессор?
SOAP основан на языке XML и расширяет некоторый протокол прикладного уровня — HTTP, FTP, SMTP и т.д. Как правило чаще всего используется HTTP. Вместо использования HTTP для запроса HTML-страницы, которая будет показана в браузере, SOAP отправляет посредством HTTP-запроса XML-сообщение и получает результат в HTTP-отклике. Для правильной обработки XML-сообщения процесс-«слушатель» HTTP (Apache или Microsoft IIS) должен предоставить SOAP-процессор, или, другими словами, должен иметь возможность обрабатывать XML.
## 112. Опишите общую структуру SOAP-сообщения.
Сообщение SOAP состоит из заголовка, элемент SOAP-ENV:Header, и основной части, элемент SOAP-ENV:Body. Заголовок может содержать метаданные, относящиеся к сообщению в целом.
## 113. Что такое и что содержит Конверт (SOAP Envelope)?
Конверт (SOAP Envelope) является самым «верхним» элементом SOAP-сообщения. Содержит корневой элемент XML-документа. Описывается с помощью Envelope с обязательным пространством имён http://www.w3.org/2003/05/soap-envelope для версии 1.2 и http://schemas.xmlsoap.org/soap для версии 1.1.
## 114. Что такое и что содержит Заголовок SOAP (SOAP Header)?
Заголовочный элемент SOAP не является обязательным, однако он был включён в пример для того, чтобы объяснить некоторые функции SOAP. Заголовок SOAP является расширением, предоставляющим способ передачи в SOAP-сообщениях информации, вообще говоря не являющейся полезной для приложения. Подобная "контрольная" информация включает, например, директивы прохождения сообщения или контекстную информацию, относящуюся к обработке сообщения. Это позволяет подстраивать SOAP-сообщения под каждое конкретное приложение. Следующие непосредственно за `env:Header` дочерние элементы называются заголовочными блоками. Они представляют логическую группировку данных, которые, как показано позже, могут быть индивидуально адресованы SOAP-узлам, встречаемым сообщением на пути от отправителя к конечному получателю.
## 115. Что такое и что содержит Тело SOAP (SOAP Body)?
Тело SOAP-сообщения является обязательным элементом внутри `env:Envelope`, содержащим основную информацию SOAP-сообщения, которая должна быть передана из начальной точки пути сообщения в конечную.
## 116. Опишите SOAP-сообщение с вложением.
Сообщение SOAP выглядит так:
- Envelope — корневой элемент, который определяет сообщение и пространство имён, использованное в документе.
- Header — содержит атрибуты сообщения, например: информация о безопасности или о сетевой маршрутизации.
- Body — содержит сообщение, которым обмениваются приложения.
- Fault — необязательный элемент, который предоставляет информацию об ошибках, которые произошли при обработке сообщений.
## 117. Что такое graphql?
GraphQL – язык запросов, используемый клиентскими приложениями для работы с данными, независимо от источников их изначального хранения: СУБД, файловое или объектное хранилище и пр. Можно сказать, что GraphQL (GQL) развивает REST-технологию, используя для передачи данных клиенту и получения их от него, простые GET или POST-запросы.
## 118. Что такое Распознаватели (resolvers) в graphql?
Resolver, или распознаватель, — функция, которая возвращает данные для определённого поля. Распознаватели возвращают данные того типа, который определён в схеме. Распознаватели могут быть асинхронными.
## 119. Из чего состоит экосистема graphql, что нужно, чтобы использовать данную технологию?
GraphQL используется для работы с данными в «вашем приложении», а не «в вашей базе данных». GraphQL — система, независимая от источников данных, то есть, для организации её работы неважно, где именно хранятся данные. GraphQL используется с различными ЯП. Рассмотрим пример использования GraphQL с JavaScript, используя NodeJS:
```
npm install express
npm install express-graphql graphql
```
## 120. Что такое валидация данных и для чего она нужна?
Валидация — это проверка значений, указанных пользователем, и отображение найденных ошибок. Служит для подтверждения корректности результатов работы программы, модели и т.д.
## 121. Где и когда выполнять валидацию данных?
Удобно проверять данные в том месте, где они попадают в программу из внешнего мира. После такой проверки можно быть уверенным, что в программу попадают правильные данные и в дальнейшем они могут использоваться без дополнительных проверок. Это может быть пользовательский интерфейс, через который человек вводит данные. Это может быть файл, содержащий настройки программы или данные, которые программа должна обработать. Это может быть база данных, в которую информация может попадать из других программ. Это может быть сетевой протокол обмена данными с другими программами. Наконец, это может быть программный интерфейс, который использует другая программа, вызывая некоторые функции или процедуры и передавая в них параметры.
## 122. Как выполнять валидацию данных?
Есть несколько вариантов валидации данных:
1. Посимвольная проверка.

	Как правило такие проверки выполняются в пользовательском интерфейсе, по мере ввода данных. Но не только. Например, лексический анализатор компилятора тоже выявляет недопустимые символы непосредственно в процессе чтения компилируемого файла. Поэтому такие проверки можно условно назвать «лексическими».
2. Проверка отдельных значений.

	Для пользовательского интерфейса это проверка значения в отдельном поле, причём выполняться она может как по мере ввода (проверяется то неполное значение, которое введено к настоящему моменту), так и после завершения ввода, когда поле теряет фокус. Для программного интерфейса (API) это проверка одного из параметров, переданных в вызываемую процедуру. Для данных, получаемых из файла, это проверка какого-то прочитанного фрагмента файла. Такие проверки, опять-таки по аналогии с компиляторной терминологией, можно назвать «синтаксическими».
3. Совокупность входных значений.

	Можно предположить, что в программу сначала передаются какие-то данные, после чего подаётся некоторый сигнал, который инициирует их обработку. Например, пользователь ввёл данные в форму или в несколько форм (в так называемом «визарде») и наконец нажал кнопку «OK». В этот момент можно выполнить так называемые «семантические» проверки, нацеленные на валидацию не только отдельных значений, но и взаимосвязей между ними, взаимных ограничений. Вполне возможна ситуация, когда каждое отдельное значение «синтаксически» корректно, но вместе они образуют несогласованный набор. Для программного интерфейса эта разновидность валидации предполагает проверку набора входных параметров вызываемой процедуры, для случая получения данных из файла это проверка всех прочитанных данных.
4. Проверка состояния системы после обработки данных.

	Наконец, есть последний способ, к которому можно прибегнуть, если валидацию непосредственно входных данных выполнить не удаётся — можно попытаться их обработать, но оставить возможность вернуть всё к исходному состоянию. Такой механизм часто называется транзакционным.
## 123. Приведите пример с поэтапной валидацией данных.
1. Проверка данных в форме при вводе.
2. Проверка данных при отправке.
3. Проверка данных на сервере.
## 124. Что такое запрос и мутация в graphql и чем они отличаются?
### Запрос
С помощью запросов GraphQL получает необходимые данные с сервера. Тип запроса Query в GraphQL — аналог GET в REST. Запросы — строки, которые отправляются в теле HTTP POST-запроса. Query описывает данные, которые необходимо получить с сервера. В ответ на этот запрос сервер присылает данные в формате JSON. Структура ответа соответствует структуре запроса. Успешные операции возвращают JSON с ключом "data" и с ключом "error", а неуспешные возвращают JSON с ключом и сообщением об ошибке. Благодаря этому удобно обрабатывать ошибки на стороне клиента.
### Мутация
Mutation — ещё один root types. С его помощью можно добавлять данные в БД. Mutation — аналог POST и PUT в REST. В ответ на этот запрос сервер присылает JSON с id записи.
## 125. Что такое сессия в рамках веб-разработки?
Сессия — диалоговое состояние между клиентом и сервером, включающее информацию о предыдущих запросах клиента и ответах сервера. В силу того, что протокол и сами веб-сервера не обеспечивают сохранение состояния, то единственной возможностью для этого является передача всей необходимой информации о запросе в нём самом.
## 126. Что такое cookie в рамках веб-разработки?
Куки, или cookies, — служебные файлы, которые создаёт браузер для получения необходимой информации о пользователе, а также небольшой фрагмент данных, отправленный веб-сервером и хранимый на компьютере пользователя. Веб-клиент всякий раз при попытке открыть страницу соответствующего сайта пересылает этот фрагмент данных веб-серверу в составе HTTP-запроса.
## 127. Опишите механизм использования cookies.
Cookie используются веб-серверами для идентификации пользователей и хранения данных о них. К примеру, если вход на сайт осуществляется при помощи cookie, то, после ввода пользователем своих данных на странице входа, cookie позволяют серверу запомнить, что пользователь уже идентифицирован и ему разрешён доступ к соответствующим услугам и операциям.
## 128. Опишите простой пример работы сессий в PHP.
Пример будет состоять из трёх файлов: `index.php`, `authorize.php` и `secretplace.php`. Файл `index.php` содержит форму, где пользователь введёт свой логин и пароль. Эта форма передаст данные файлу `authorize.php`, который в случае успешной авторизации допустит пользователя к файлу `secretplace.php`, а в противном случае выдаст сообщение об ошибке. При этом можно в глобальный массив `$_SESSION` и вывести имя пользователя на экран.
## 129. Опишите способы защиты сессии пользователя.
- Использование cookie

	По умолчанию вся информация о сессии, включая ID, передается в cookie. Но так бывает не всегда. Некоторые пользователи отключают cookie в своих браузерах. В таком случае браузер будет передавать идентификатор сессии в URL:
	```
	www.example.org/index.php?PHPSESSID=n2cnj59d7s3p30fjs0jfn28nf
	```

	Здесь ID передаётся в открытом виде, в отличие от сессии через cookie, когда информация скрыта в HTTP-заголовке. Самым простым способом защиты от этого будет запрет передачи идентификатора сессии через адресную строку. Сделать это можно, прописав следующее в конфигурационном файле Apache-сервера `.htaccess`:
	```htaccess
	php_flag session.use_only_cookies on
	```

- Шифрование

	Если на вашем сайте должна обрабатываться конфиденциальная информация, такая как номера кредитных карт (привет от Sony), следует использовать SSL3.0 или TSL1.0 шифрование. Для этого при установке cookie следует указывать true для параметра secure. Если вы храните пароль сессии в переменной `$_SESSION`, то не стоит хранить его в открытом виде.
	```php
	if ($_SESSION['password'] == $userpass) {
		// код
	}
	```

	Приведённый выше код небезопасен, так как пароль хранится в виде обычного текста в переменной сессии. Вместо этого используйте md5-шифрование, примерно так:
	```php
	if ($_SESSION['md5password'] == md5($userpass)) {
		// код
	}
	```

- Проверка браузера

	Чтобы исключить возможность использования сессии с другого браузера (компьютера), следует ввести проверку поля HTTP-заголовка user-agent:
	```php
	session_start();
	if (isset($_SESSION['HTTP_USER_AGENT'])) {
		if ($_SESSION['HTTP_USER_AGENT'] != md5($_SERVER['HTTP_USER_AGENT'])) {
			// код
		}
	} else $_SESSION['HTTP_USER_AGENT'] = md5($_SERVER['HTTP_USER_AGENT']);
	```

- Срок действия сессии

	Ограничьте время жизни сессии, а также время действия cookie. По умолчанию срок действия сессии 1440 секунд. Изменить это значение можно через `php.ini` и `.htaccess`. Пример для `.htaccess`:
	```htaccess
	# Время жизни сессии в секундах
	php_value session.gc_maxlifetime 3600
	# Время жизни куки в секундах
	php_value session.cookie_lifetime 3600

- Привязка по IP-адресу

	В определённых ситуациях следует установить привязку по IP-адресу. В основном когда количество пользователей ограничено и имеют статичные IP. Проверка может быть либо по списку разрешенных IP-адресов:
	```php
	include ("ip_list.php");

	//$ip_white_list = array (
		'admin1' => '111.222.333.444',
		'admin2' => '555.666.777.888'
	);

	if (!empty(array_search($_SERVER['REMOTE_ADDR'],$ip_white_list))) {
		header("Location: admin.php");
	} else echo 'ACCESS DENY!';
	```

	либо по IP-адресу для каждого запроса (только для статичных IP):
	```php
	if (isset($_SESSION['ip']) and $_SESSION['ip'] == $_SERVER['REMOTE_ADDR']) {
		header("Location: admin.php");
	} else {
		session_unset();
		$_SESSION['ip'] = $_SERVER['REMOTE_ADDR'];
	}
	```
## 130. Верно ли, что можно хранить данные сессии в БД?
Сессия - необходимые горячие данные пользователя, что нужно сохранить между запросами. БД - одно из самых медленных хранилищ этих данных. В файлах кстати тоже не стоит хранить. При большой нагрузке io будет подтормаживать. Длительный период сессии обычно не хранятся, вместо этого на клиент задаётся token, по которому человек через много времени может автоматически авторизироваться.
## 131. Опишите жизненный цикл сессии.
Когда вы запускаете или продолжаете сеанс с помощью `session_start($_SESSION)` выполнение скрипта заканчивается, и данные сохраняются обратно в файл. Поэтому, когда вы устанавливаете переменную сеанса, она не сохраняется сразу. Можно заставить сеанс сохранять данные, вызывая `session_write_close()` и `session_set_save_handler()`. Требуется шесть аргументов, каждый из которых является обратным вызовом, который обрабатывает определённую стадию жизненного цикла сеанса:
1. Открытие файла сеанса.
2. Закрытие файла сеанса.
3. Чтение данных сеанса.
4. Запись данных сеанса.
5. Уничтожение сессии.
6. Сборка мусора из файла сессии и данных.

Вы должны зарегистрировать функцию для каждого этапа жизненного цикла, иначе PHP выдаст предупреждение о том, что не может найти функцию.
## 132. Верно ли, что можно убрать механизм обработки сессий?
Да, но это может повлиять на безопасность сайта. Не будет возможности отслеживать действия пользователей, анализировать их для дальнейших действий, в случае подозрительного поведения. Также очень легко будет подвергнуться атакам со стороны взломщиков и хакеров.
## 133. Опишите примеры настройки сессии во время выполнения.
`session.save_handler` определяет имя обработчика, который используется для хранения и извлечения данных, связанных с сессией. По умолчанию имеет значение `files`. Следует обратить внимание, что некоторые модули могут зарегистрировать собственные обработчики (`save_handler`). Текущие зарегистрированные обработчики отображаются в `phpinfo()`.
## 134. Опишите директивы конфигурации файловой системы и потоков в PHP.
- `allow_url_fopen`

	Данная директива включает поддержку обёрток URL (URL wrappers), которые позволяют работать с объектами URL как с обычными файлами. Обёртки, доступные по умолчанию, служат для работы с удалёнными файлами с использованием FTP или HTTP протокола. Некоторые модули, например, zlib, могут регистрировать собственные обёртки.

- `allow_url_include`

	Эта опция позволяет использование обёрток fopen, которые поддерживают работу с URL, в функциях `include`, `include_once`, `require`, `require_once`.

- `user_agent`

	Устанавливает отсылаемую PHP строку "User-Agent".

- `default_socket_timeout`

	Значение времени ожидания по умолчанию (в секундах) для потоков, использующих сокеты. Отрицательное значения означает бесконечное время ожидания.

- `from`

	Адрес email, используемый в соединениях FTP без авторизации, а также в качестве значения заголовка From в HTTP соединениях при использовании ftp и http обёрток, соответственно.

- `auto_detect_line_endings`

	Когда данная директива включена, PHP проверяет данные, получаемые функциями `fgets()` и `file()` с тем, чтобы определить способ завершения строк (Unix, MS-Dos или Macintosh). Эта директива позволяет PHP взаимодействовать с системами Macintosh, однако, по умолчанию эта директива выключена, поскольку при её использовании возникает (несущественная) потребность в дополнительных ресурсах для определения символа окончания первой строки, а также потому, что программисты, использующие в системах Unix символы возврата каретки в качестве разделителей, столкнутся с обратно-несовместимым поведением PHP.
## 135. Какой тип ресурса использует файловая система. Опишите данный тип.
Файловая система использует потоки (streams) в качестве собственного типа ресурсов. Потоки были введены как инструмент для работы с файлами, сетевого обмена, сжатия данных и выполнения других операций с помощью одного общего набора функций. Выражаясь простыми понятиями, поток (stream) - ресурс (resource), который ведёт себя как источник непрерывной последовательности данных. Это означает, что из потока можно последовательно читать данные, равно как и записывать в него. Также возможно перемещаться в разные позиции внутри потока.
## 136. Как открыть и закрыть файл с помощью PHP.
Функция `fopen()` в PHP — встроенная функция, которая используется для открытия файла или URL-адреса. В случае сбоя, она возвращает `FALSE` и выдаёт ошибку. Если вам нужно скрыть вывод ошибки добавьте символ `@` перед именем функции. Функция `fclose()` используется, чтобы закрыть открытый файл.
## 137. Как производится чтение и запись файлов в PHP.
Для простого отображения всего содержимого файла идеально подходит функция `readfile()`. Для записи текстовых данных в файл существует две идентичные функции: `fputs()`, `fwrite()`.
### Чтение файла
Для чтения файла можно использовать несколько функций. Для построчного чтения используется функция `fgets()`, которая получает дескриптор файла и возвращает одну считанную строку. Пройдём построчно по всему файлу:
```php
$fd = fopen("form.php", 'r') or die("не удалось открыть файл");
while (!feof($fd)) {
	$str = htmlentities(fgets($fd));
	echo $str;
}
fclose($fd);
```
При каждом вызове `fgets()` PHP будет помещать указатель в конец считанной строки. Чтобы проследить окончание файла, используется функция `feof()`, которая возвращает `true` при завершении файла. И пока не будет достигнут конец файла, мы можем применять функцию `fgets()`.

Если нам надо прочитать файл полностью, то мы можем облегчить себе жизнь, применив функцию `file_get_contents()`:
```php
$str = htmlentities(file_get_contents("form.php"));
echo $str;
```
При этом нам не надо открывать явно файл, получать дескриптор, а затем закрывать файл.

Также можно провести поблочное считывание, то есть считывать определенное количество байт из файла с помощью функции `fread()`:
```php
$fd = fopen("form.php", 'r') or die("не удалось открыть файл");
while (!feof($fd)) {
	$str = htmlentities(fread($fd, 600));
	echo $str;
}
fclose($fd);
```
Функция `fread()` принимает два параметра: дескриптор считываемого файла и количество считываемых байтов. При считывании блока указатель в файле становится в конец этого блока. И также с помощью функции `feof()` можно отследить завершение файла.
### Запись в файл
Для записи файла применяется функция `fwrite()`, которая записывает в файл строку:
```php
$fd = fopen("hello.txt", 'w') or die("не удалось создать файл");
$str = "Привет мир";
fwrite($fd, $str);
fclose($fd);
```
Аналогично работает другая функция `fputs()`:
```php
$fd = fopen("hello.txt", 'w') or die("не удалось создать файл");
$str = "Привет мир";
fputs($fd, $str);
fclose($fd);
```
## 138. Опишите как считать только часть файла, как считывать файл последовательно и считать весь файл целиком.
- `fgets($file, $length)` – функция считывает строку длиною `$length`.
- Функция `fgets()` используется для чтения одной строки из файла.
- Функция `fgetc()` используется для чтения одного символа из файла.
- Функция `feof()` полезна для цикла работающего с данным неизвестной длины.
## 139. Как производится создание и удаление файлов с помощью PHP.
Чтобы создать файл PHP, можно использовать функцию `fopen()` в режиме доступа `w` или `w+`. Или функцию `touch()`. Она устанавливает время изменения файла. При отсутствии элемента с искомым именем он будет создан. Удалить файл можно с помощью функции `unlink()`.
## 140. С помощью каких функций и какую информацию о файле можно получить с помощью PHP?
Для получения информации о файлах в PHP используется целый ряд функций:
- `fileexists($filename)` – проверяет, существует ли элемент;
- `fileatime($filename)` – возвращает время последнего открытия;
- `filesize($filename)` – возвращает байтовый размер файла;
- `filetype($filename)` – возвращает тип файла.
## 141. Что такое DOM?
DOM означает объектную модель документа. Это программный интерфейс, который позволяет нам создавать, изменять или удалять элементы из документа. Мы также можем добавлять события к этим элементам, чтобы сделать нашу страницу более динамичной. Модель DOM рассматривает документ HTML как дерево узлов.
## 142. Как создать документ и работать с ним с помощью модуля DOM?
...
## 143. Что такое JSON?
JSON — формат, который хранит структурированную информацию и в основном используется для передачи данных между сервером и клиентом. Файл JSON представляет собой более простую и лёгкую альтернативу расширению с аналогичными функциями XML (Extensive Markup Language).
## 144. Как декодировать строку JSON и вернуть JSON-представление данных?
Структуры JSON-данных очень похожи на массивы PHP. PHP имеет встроенные функции для кодирования и декодирования данных JSON. Это функции `json_encode()` и `json_decode()` соответственно. Обе функции работают только со строковыми данными в кодировке UTF-8.
## 145. Как проанализировать и выявить ошибки при кодировании и декодировании JSON?
`json_last_error` — возвращает последнюю ошибку (если она есть), произошедшую во время последнего кодирования/декодирования JSON если при вызове не использовался флаг `JSON_THROW_ON_ERROR`.
## 146. Опишите создание, сохранение, парсинг XML-документа я помощью PHP.
В PHP XML файлы создаются с помощью DOM-функций, которые создают дерево объектов, в точности повторяющее дерево элементов XML-документа. Так как DOM строит дерево всего документа, то и ресурсов он потребляет немало (памяти и процессора он потребляет достаточно). Для создания XML документа используется класс – DomDocument. Пример парсинга:
```xml
<?xml version='1.0'?>
	<worker>
		<name>Коля</name>
		<age>25</age>
		<salary>1000</salary>
	</worker>
```
Пример PHP:
```php
$xml = simplexml_load_file(путь к файлу или урл);
echo $xml->name; //выведет 'Коля'
echo $xml->age; //выведет 25
echo $xml->salary; //выведет 1000
```
## 147. Что такое драйвер в рамках взаимодействия с СУБД?
Драйвер - способ подключения к конкретному серверу конкретной БД. Все БД имеют разные протоколы для доступа к серверу БД.
## 148. Опишите добавление записи в рамках использования модуля mysqli для взаимодействия с БД MYSQL.
mysqli (MySQL Improved) — это расширение PHP, которое добавляет в язык полную поддержку баз данных MySQL. Это расширение поддерживает множество возможностей современных версий MySQL.
```php
if (isset($_POST["username"]) && isset($_POST["userage"])) {
	$conn = new mysqli("localhost", "root", "mypassword", "testdb2");
	if ($conn->connect_error) {
		die("Ошибка: $conn->connect_error");
	}
	$name = $conn->real_escape_string($_POST["username"]);
	$age = $conn->real_escape_string($_POST["userage"]);
	$sql = "INSERT INTO Users (name, age) VALUES ('$name', $age)";
	if ($conn->query($sql)) {
		echo "Данные успешно добавлены";
	} else echo "Ошибка: $conn->error";
	$conn->close();
}
```
## 149. Что такое постоянное соединение, опишите проблемы данного подхода и его решение в модуле mysqli.
Идея постоянных подключений состоит в том, чтобы соединение между клиентским процессом и базой данных можно было использовать повторно, особенно когда требуется создавать и закрывать соединения множество раз. Это бы позволило снизить накладные расходы на создание новых подключений каждый раз, когда они требуются, засчёт использования существующих кешированных подключений, свободных для повторного использования. При использовании постоянных соединений можно столкнуться с проблемой, которая заключается в том, что клиенты могут оставлять такие подключения в непредсказуемом состоянии. Например, клиент ставит блокировку на таблицу, а затем аварийно завершает работу. То есть блокировка снята не будет. Новый клиентский процесс, использующий это подключение повторно, получит его как есть, и вынужден будет провести какую-то очистку подключения, прежде чем начать его использовать. Соответственно, в задачи программиста входит ещё и проверка подобных ситуаций и внедрение кода, осуществляющего такую очистку. Тем не менее, в mysqli эта проблема решена. В модуле есть встроенный функционал, осуществляющий очистку соединений и переводящий их в состояние пригодное для использования. Код очистки, реализованный в mysqli включает следующие операции:
- Откат активных транзакций
- Закрытие и удаление временных таблиц
- Cнятие блокировки с таблиц
- Сброс переменных сессии
- Закрытие подготовленных запросов (всегда происходит в PHP)
- Закрытие обработчиков
- Снятие блокировок, установленных функцией `GET_LOCK()`
Это позволяет быть уверенным в том, что возвращённые из пула соединения готовы к использованию в клиентских процессах. Модуль mysqli делает очистку соединений автоматически путём вызова C-API функции `mysql_change_user()`.
## 150. Опишите основные особенности БД MongoDB.
MongoDB - кроссплатформенная документоориентированная база данных NoSQL с открытым исходным кодом. Она не требует описания схемы таблиц, как в реляционных БД. Данные хранятся в виде коллекций и документов. Между коллекциями нет сложных соединений типа `JOIN`, как между таблицами реляционных БД. Обычно соединение производится при сохранении данных путём объединения документов. Данные хранятся в формате BSON (бинарные JSON-подобные документы). У коллекций не обязательно должна быть схожая структура. У одного документа может быть один набор полей, в то время как другого документа — совершенно другой (как тип, так и количество полей). В одном документе могут быть поля разных типов данных, данные не нужно приводить к одному типу. Основное преимущество MongoDB заключается в том, что она может хранить любые данные, но эти данные должны быть в формате JSON.
## 151. Опишите процесс добавления новой записи в СУБД MongoDB с помощью соответствующего драйвера.
Для добавления в коллекцию могут использоваться три её метода:
- insertOne(): добавляет один документ
- insertMany(): добавляет несколько документов
- insert(): может добавлять как один, так и несколько документов
Пример добавления:
`db.users.insertOne({"name": "Tom", "age": 28, languages: ["english", "spanish"]});`
## 152. Опишите процесс получения и обработки записей с помощью драйвера MongoDB.
Для получения всех записей в коллекции используйте метод `find()` экземпляра коллекции. Обновление записи происходит с помощью метода `updateOne()`, который принимает условие для записей, которые необходимо обновить, и объект со свойством `$set`, в значении которого указываются, какие именно поля нужно изменить. За удаление записей отвечают методы `deleteOne()` и `deleteMany()`.
## 153. Опишите получение записей в рамках использования модуля mysqli для взаимодействия с БД MYSQL.
При выполнении команды `SELECT` метод `query()` объекта mysqli возвращает набор полученных строк, который мы можем перебрать с помощью цикла. Например, перебор с помощью цикла `foreach`.
```php
$sql = "SELECT * FROM Users";
if ($result = $conn->query($sql)) {
	foreach ($result as $row) {
		$userid = $row["id"];
		$username = $row["name"];
		$userage = $row["age"];
	}
}
```
Обратите внимание, что первым параметром для функциии `mysqli_query()` передаётся ресурс подключения, полученный от функции `mysqli_connect()`, вторым параметром следует строка с SQL-запросом.
При запросах на изменение данных (не `SELECT`) результатом выполнения будет логическое значение — `true` или `false`.
`false` будет означать, что запрос выполнить не удалось. Для получения строки с описанием ошибки существует функция `mysqli_error($link)`.
## 154. Опишите поиск записей, подсчет и ограничение выборки с помощью драйвера MongoDB.
### Поиск
Наиболее простой способом получения содержимого БД представляет использование функции `find()`. Действие этой функции во многом аналогично обычному запросу `SELECT * FROM Table`, который применяется в SQL и который извлекает все строки. Например, чтобы извлечь все документы из коллекции users, созданной в прошлой теме, мы можем использовать команду `db.users.find()`.

Для вывода документов в более удобном наглядном представлении мы можем добавить вызов метода `pretty()`.
### Ограничение выборки
Однако что, если нам надо получить не все документы, а только те, которые удовлетворяют определенному требованию. Например, мы ранее в базу добавили следующие документы:
```
> db.users.insertOne({"name": "Tom", "age": 28, languages: ["english", "spanish"]})
> db.users.insertOne({"name": "Bill", "age": 32, languages: ["english", "french"]})
> db.users.insertOne({"name": "Tom", "age": 32, languages: ["english", "german"]})
```
Выведем все документы, в которых `name=Tom`:
```
> db.users.find({name: "Tom"})
```
Такой запрос выведет нам два документа, в которых `name=Tom`.

Теперь более сложный запрос: нам надо вывести те объекты, у которых `name=Tom` и одновременно `age=32`. То есть на языке SQL это могло бы выглядеть так: `SELECT * FROM Table WHERE Name='Tom' AND Age=32`. Данному критерию у нас соответствует последний добавленный объект. Тогда мы можем написать следующий запрос:
```
> db.users.find({name: "Tom", age: 32})
```
Какие-то документы могут иметь определенное свойство, другие могут его не иметь. Что если мы хотим получить документы, в которых отсутствует определенное свойство? В этом случае для свойства передается значение `null`. Например, найдем все документы, где отсутствует свойство `languages`:
```
> db.users.find({languages: null})
```
### Подсчёт
С помощью функции `count()` можно получить число элементов в коллекции:
```
> db.users.count()
```
## 155. Что такое Composer и для чего он используется?
Composer — пакетный менеджер уровня приложений для языка программирования PHP, который предоставляет средства по управлению зависимостями в PHP-приложении.
## 156. Опишите работу с календарем в PHP: опишите преобразование дат из одного календаря в другой.
Существует множество функций для работы с календарём в PHP:
- `cal_days_in_month` — Возвращает количество дней в месяце для заданного года и календаря;
- `cal_from_jd` — Преобразует дату, заданную в юлианском календаре, в дату указанного календаря;
- `cal_info` — Возвращает информацию о заданном календаре;
- `cal_to_jd` — Преобразует заданную дату в юлианскую;
- `easter_date` — Получить метку времени Unix, соответствующую полуночи на Пасху в заданном году;
- `easter_days` — Получить количество дней между 21 марта и Пасхой в заданном году;
- `frenchtojd` — Преобразует дату Французского республиканского календаря в количество дней в Юлианском летоисчислении;
- `gregoriantojd` — Преобразует дату по григорианскому календарю в количество дней в юлианском летоисчислении;
- `jddayofweek` — Возвращает день недели;
- `jdmonthname` — Возвращает название месяца;
- `jdtofrench` — Переводит число дней в юлианском летоисчислении в дату по французскому республиканскому календарю;
- `jdtogregorian` — Переводит число дней в юлианском летоисчислении в дату по Григорианскому календарю;
- `jdtojewish` — Переводит количество дней из юлианского календаря в дату по еврейскому календарю;
- `jdtojulian` — Переводит число дней в юлианском летоисчислении в дату по юлианскому календарю;
- `jdtounix` — Переводит число дней в юлианском летоисчислении в метку времени Unix;
- `jewishtojd` — Переводит дату по еврейскому календарю в число дней в юлианском летоисчислении;
- `juliantojd` — Переводит дату по юлианскому календарю в число дней в юлианском летоисчислении;
- `unixtojd` — Переводит метку времени Unix в юлианский день.
```php
$date = new DateTime('2000-01-01');
echo $date->format('Y-m-d H:i:s');
```
## 157. Опишите понятие серверное время и процесс форматирования времени для разных часовых поясов.
Серверное время – время, установленное на сервере. Серверное время преобразуется согласно часовому поясу по UTC+, то есть по смещению от нулевого меридиана.
Пример вывода нескольких часовых поясов:
```php
$default_timezone = date_default_timezone_get();

echo $default_timezone;
echo '<br><br><br>';
$moscow_time = date("H:i:s");
echo 'Московское время ';
echo $moscow_time ;
echo '<br><br><br>';

date_default_timezone_set('Europe/Helsinki');
echo '<br><br><br>';
$helsinki_time = date("H:i:s");
echo 'Время в Хельсинки ';
echo $helsinki_time;
echo '<br><br><br>';

date_default_timezone_set('Europe/Stockholm');
echo '<br><br><br>';
$stockholm_time = date("H:i:s");
echo 'Время в Стокгольме ';
echo($stockholm_time);
echo '<br><br><br>';

date_default_timezone_set('Europe/Moscow');
echo '<br><br><br>';
```
## 158. Опишите способ получения времени заката и рассвета с использованием языка программирования PHP.
```php
/* Закат:
calculate the sunset time for Lisbon, Portugal
Latitude: 38.4 North
Longitude: 9 West
Zenith ~= 90
offset: +1 GMT */
echo date("D M d Y").', время захода солнца: '.date_sunset(time(), SUNFUNCS_RET_STRING, 38.4, -9, 90, 1);
/* Восход:
расчёт времени восхода солнца в Лиссабоне, Португалия
Latitude: 38.4 North
Longitude: 9 West
Zenith ~= 90
offset: +1 GMT */
echo date("D M d Y").', время восхода солнца: '.date_sunrise(time(), SUNFUNCS_RET_STRING, 38.4, -9, 90, 1);
```
## 159. Опишите константы, используемые в модуле “Время и дата”.
В модуле используются константы `MINYEAR` и `MAXYEAR`, которые равны `1` и `9999` соответственно. Это минимальное и максимально возможное значение года, используемые в библиотеке.
## 160. Приведите принципы арифметики даты и времени.
```php
//Добавление интервала
$dt = $dt->add(new DateInterval("PT3H"));
//Добавление часов
$dt = $dt->modify("+24 hours");
//Добавление месяца
$dt = $dt->modify("+1 month");
//Добавление последнего дня месяца
$dt = $dt->modify("last day of next month");
```
## 178. С помощью какой библиотеки возможно простое и эффективное генерирование документов в формате PDF?
mPDF
## 179. С помощью какой библиотеки возможен эффективный парсинг HTML/XML?
Goutte
## 180. С помощью какой библиотеки возможно создание диаграмм на движке GOOGLE?
GoogChart
## 181. С помощью какой библиотеки возможно сканирование конфигурационного файла PHP на предмет безопасности?
IniScan
## 182. С помощью какой библиотеки возможен анализ HTML и удаление вредоносного кода для защиты от XSS атак.
HTML Purifier
## 183. С помощью какой библиотеки возможно построение графиков, диаграмм и другого структурированного контента на PHP?
jpGraph
## 184. С помощью какой библиотеки облегчается процесс загрузки и валидации файлов на PHP?
RespectValidation
## 185. Назовите основные признаки ООП.
Абстракция, полиморфизм, наследование, инкапсуляция
+ Абстракция — отделение концепции от её экземпляра;
+ Полиморфизм — реализация задач одной и той же идеи разными способами;
+ Наследование — способность объекта или класса базироваться на другом объекте или классе. Это главный механизм для повторного использования кода. Наследственное отношение классов четко определяет их иерархию;
+ Инкапсуляция — размещение одного объекта или класса внутри другого для разграничения доступа к ним.
## 186. Опишите как определить класс в PHP.
Каждое определение класса начинается с ключевого слова `class`, затем следует имя класса, и далее пара фигурных скобок, которые заключают в себе определение свойств и методов этого класса.
```php
class SimpleClass {
	// объявление свойства
	public $var = 'значение по умолчанию';

	// объявление метода
	public function displayVar() {
		echo $this->var;
	}
}
```
## 187. Как создать экземпляр класса в PHP.
Для создания экземпляра класса используется директива `new`. Новый объект всегда будет создан, за исключением случаев, когда он содержит конструктор, в котором определён вызов исключения в случае возникновения ошибки. Рекомендуется определять классы до создания их экземпляров (в некоторых случаях это обязательно).
```php
$instance = new SimpleClass();
// Это же можно сделать с помощью переменной:
$className = 'SimpleClass';
$instance = new $className(); // new SimpleClass()
```
## 231. Что включает в себя фреймворк Laravel?
Laravel включает в себя встроенную поддержку для аутентификации, локализации, модели, представления, сессий, маршрутизации и других механизмов, поддержку контроллеров, которые сделали фреймворк полностью MVC-совместимым, встроенную поддержку для инверсии управления и шаблонизатор Blade, интерфейс командной строки (CLI) под именем «Artisan», встроенную поддержку нескольких систем управления базами данных, миграции баз данных в виде контроля версий, обработку событий, выгрузка таблиц базы данных для первоначальной популяции, поддержку очередей сообщений, встроенную поддержку отправки различных типов электронной почты и поддержку «мягкого» удаления записей базы данных, поддержку планирования периодически выполняемых задач через пакет Scheduler, слой абстракции Flysystem, который позволяет использовать удаленное хранилище так же, как и локальные файловые системы, улучшенную обработку активов пакета через Elixir и упрощенная аутентификация с внешней стороны через дополнительный пакет Socialite, Laravel Dusk, Laravel Mix, Blade Components и Slots, Markdown Emails, автоматические фасады, улучшения маршрута.
## 232. Опишите из чего состоит экосистема Laravel
PHP, Composer, Dotenv, PSR-4, Eloquent ORM, Flysystem, Elixir, HHVM, Homestead, Rocketeer
## 233. Опишите фреймворк Symfony
Свободный PHP фреймворк для быстрой разработки веб-приложений и решения рутинных задач веб-программистов. Разработка и поддержка фреймворка спонсируется французской компанией Sensio.
Symfony состоит из набора не связанных между собой компонентов, которые можно использовать повторно в проектах.
Symfony позволяет устанавливать сторонние пакеты, библиотеки, компоненты и настраивать их с помощью конфигурации в форматах YAML, XML, PHP, а также .env файлах.
Symfony не обеспечивает компонент для работы с базой данных, но обеспечивает тесную интеграцию с библиотекой Doctrine.
Symfony предоставляет функцию почтовой программы на основе популярной библиотеки Swift Mailer. Эта почтовая программа поддерживает отправку сообщений с ваших собственных почтовых серверов, а также с использованием популярных почтовых провайдеров, таких как Mandrill, SendGrid и Amazon SES.
Механизм интернационализации позволяет установить и произвести перевод сообщений веб-приложения на основе выбранного языка или страны.
Symfony предлагает систему логирования ошибок приложения, а также подключить библиотеку логирования Monolog.
## 234. Опишите преимущества фреймворка Symfony.
+ Мощная экосистема вокруг фреймворка, с хорошим сообществом и множеством разработчиков.
+ Хорошая и постоянно обновляемая документация для всех версий фреймворка.
+ Множество различных не связанных компонентов для повторного использования.
+ Предлагает механизм функциональных и модульных тестов для нахождения ошибок в веб-приложении.
+ Подходит для сложных и нагруженных веб-проектов.электронной коммерции.
## 235. Опишите недостатки фреймворка Symfony.
Не смотря на хорошую документацию, фреймворк является сложным для изучения.
## 236. Опишите фреймворк Code Igniter.
Это популярный PHP микро-фреймворк с открытым исходным кодом, для разработки веб-систем и приложений.
В CodeIgniter компоненты загружаются и процедуры выполняются только по запросу, а не глобально. Система не делает никаких предположений относительно того, что может потребоваться помимо минимальных основных ресурсов, поэтому система по умолчанию очень легкая.
Компоненты фреймворка слабо связаны между собой и не зависят друг от друга. Чем меньше компонентов зависит друг от друга, тем более гибкой и многоразовой становится система.
Хотя CodeIgniter работает довольно быстро, объем динамической информации, отображаемой на страницах, будет напрямую зависеть от используемых ресурсов сервера, памяти и циклов обработки, которые влияют на скорость загрузки страниц.
Поэтому CodeIgniter позволяет кэшировать страницы для достижения максимальной производительности. с помощью встроенного компонента кэширования.
## 237. Опишите преимущества фреймворка Code Igniter.
+ Отличная документация и англоязычное сообщество.
+ Высокая производительность фреймворка.
+ Небольшой размер фреймворка.
+ Предоставляет легкие и простые решения для разработки. 
+ Подходит для быстрой разработки небольших сайтов и веб-приложений. 
+ Структура фреймворка не требует строгих правил кодирования. 
+ Не требует сложной настройки, почти нулевая конфигурация. 
+ MVC-архитектура веб-приложения. 
+ Слабая связанность компонентов. 
+ Множество подключаемых библиотек и помощников.
## 238. Опишите недостатки фреймворка Code Igniter.
- Задержка в развитии и переходе на новые технологии
- Сложности с регистрацией, авторизацией и разграничением доступа в различных версиях CodeIgniter.
## 239. Опишите фреймворк Yii2.
Объектно-ориентированный компонентный фреймворк для PHP, реализующий парадигму MVC (Model-View-Controller). Yii является акронимом от “Yes It is”, на русском пишется и читается как “йии”. Yii2 является второй версией фреймворка Yii.
## 240. Опишите преимущества фреймфорка Yii2.
+ Фреймворк прост в понимании. 
+ Легко адаптируется под большие и маленькие проекты. 
+ Имеет большое количество решений рутинных задач из коробки. К примеру, шаблон advanced  обладает механизмом авторизации и аутентификации. Это довольно нужный механизм и он не очень прост в реализации. 
+ Имеет замечательную документацию, гайды по старту и различные рецепты. 
+ Yii2 популярен и довольно стар (релиз-то был аж в 2014 году), поэтому на рынке в много вакансий yii2-разработчиков, а с помощью развитого сообщества ответы на 90% вопросов вы найдете при легком гуглеже. 
+ С помощью шаблонов и gii фреймворк подсказывает начинающему разработчику, как правильно располагать файлы. Сначала разработчик начинает повторять за тем, как это сделано в фреймворке, а потом понимает почему это хорошо. Разработчики фреймворка будто делятся опытом с новичком
## 241. Опишите Недостатки фреймворка Yii2.
- Наличие различных антипаттернов в проекте — например, одиночка или божественный объект. 
- Встроенный класс User, являющийся потомком от ActiveRecord, показывает, как делать не нужно. Учит начинающих программистов, что классы, наследуемые от ActiveRecord, нужно раздувать различными методами, не связанными с работой с БД. 
- Сильная связность модулей в приложении. Говорят, эта проблема в Yii3 будет решена. 
- Медленное развитие.
## 250. Что такое ViewResolver?
ViewResolvers — это объекты, отвечающие за получение объектов View для конкретной операции и локали. Обычно контроллеры просят ViewResolvers переслать представление с определенным именем (строка, возвращаемая методом контроллера), а затем все средства разрешения представления в приложении выполняются в упорядоченной цепочке, пока один из них не сможет разрешить это представление, в каком случае объект View возвращается и ему передается управление для рендеризации HTML.
## 251. Опишите REST контроллеры.
REST, Representational State Transfer, является архитектурным стилем для обеспечения стандартов между компьютерными системами в сети, что облегчает для систем обмен данными друг с другом. Системы, отвечающие требованиям REST и часто называемые RESTful, характеризуются тем, что не имеют сохранения состояния и разделяют интересы клиента и сервера.

Существует 4 основных метода НТТР, которые мы используем в запросах для взаимодействия с ресурсами в системе REST:
+ GET — получение конкретного ресурса (по id) или коллекцию ресурсов;
+ POST — создание нового ресурса;
+ PUT — обновление конкретного ресурса (по id);
+ DELETE — удаление конкретного ресурса по id.
## 252. Что такое HttpMessageConverter?
Spring MVC использует интерфейс `HttpMessageConverter` для преобразования HTTP-запросов и ответов. Разумные значения по умолчанию включены "из коробки". Например, объекты могут быть автоматически преобразованы в JSON (с помощью библиотеки Jackson) или XML (с помощью расширения Jackson XML, если оно доступно, или с помощью JAXB, если расширение Jackson XML недоступно). По умолчанию строки кодируются в UTF-8.
+ canRead (MediaType) → Может ли этот конвертер читать (JSON | XML | YAML | и т. д.)? Переданный здесь MediaType обычно является значением из заголовка запроса Content-Type.
+ canWrite (MediaType) → Может ли этот преобразователь писать (JSON | XML | YAML | и т. д.)? Тип MediaType, переданный здесь, обычно является значением из заголовка запроса Accept.
+ read(Object, InputStream, MediaType) → Читать мой Java-объект из (JSON | XML | YAML | и т. д.) InputStream
+ write(Object, OutputStream, MediaType) → Записать мой Java-объект в OutputStream как (JSON | XML | YAML | и т. д.)
## 253. Какие есть HttpMessageConverters?
По умолчанию используется следующее Экземпляры HttpMessageConverters предварительно включены:

+ ByteArrayHttpMessageConverter – преобразует массивы байтов;
+ StringHttpMessageConverter – преобразует строки;
+ ResourceHttpMessageConverter – преобразует org.springframework.core.io.Resource для любого типа потока октетов;
+ SourceHttpMessageConverter – преобразует javax.xml.transform.Источник;
+ FormHttpMessageConverter – преобразует данные формы в/из многозначной карты String> . String>;
+ Jaxb2RootElementHttpMessageConverter преобразует объекты Java в/из XML (добавляется только в том случае, если JAXB2 присутствует в пути к классу);
+ MappingJackson2HttpMessageConverter преобразует JSON (добавляется только в том случае, если Jackson 2 присутствует в пути к классу)
+ MappingJacksonHttpMessageConverter преобразует JSON (добавляется только в том случае, если Джексон присутствует в пути к классу)
+ AtomFeedHttpMessageConverter преобразует каналы Atom (добавляется только в том случае, если в пути к классу присутствует Rome);
+ RssChannelHttpMessageConverter – преобразует RSS-каналы.
## 254. В чем разница между Spring MVC и Spring Boot?
+ Spring MVC - полный HTTP-ориентированный MVC-фреймворк, управляемый Spring Framework и основанный на сервлетах. Это было бы эквивалентно JSF в стеке JavaEE. Наиболее популярными элементами в нем являются классы, помеченные аннотацией `@Controller`, где вы реализуете методы, к которым вы можете обращаться, используя различные HTTP-запросы. Он имеет эквивалент `@RestController` для реализации API на основе REST.
+ Spring boot - утилита для быстрой настройки приложений, предлагающая готовую конфигурацию для создания приложений на базе Spring. Как вы, возможно, знаете, Spring объединяет широкий спектр различных модулей под своей эгидой, таких как spring-core, spring-data, spring-web (кстати, включая Spring MVC) и так далее. С помощью этого инструмента вы можете сказать Spring, сколько из них использовать, и вы получите быструю настройку для них (вы можете изменить его самостоятельно позже).
Итак, Spring MVC - фреймворк, который будет использоваться в веб-приложениях, а Spring Boot - готовый к работе инициализатор проекта на основе Spring.
## 255. Какой тип ввода HTTP-запроса понимает Spring MVC?
Spring MVC понимает практически всё, что предлагает HTTP, с помощью сторонних библиотек.
Это означает, что вы можете добавить в него тела запросов JSON, XML или HTTP (Multipart) Fileuploads, и Spring будет удобно конвертировать этот ввод в объекты Java.
## 256. Какие HTTP-ответы может создавать Spring MVC?
Spring MVC может записывать всё, что угодно в HttpServletResponse с помощью сторонних библиотек.
Будь то HTML, JSON, XML или даже тела ответов WebSocket. Более того, он берёт ваши объекты Java и генерирует эти тела ответов для вас.
## 257. В чем разница между контроллером и REST контроллером?
+ Контроллер по умолчанию возвращают HTML пользователям с помощью библиотеки шаблонов, если вы не добавите аннотацию `@ResponseBody` к определённым методам, которые также позволяют возвращать XML/JSON.
+ Исходный код REST контроллера показывает, что на самом деле это контроллер с добавленной аннотацией `@ResponseBody`. Что эквивалентно написанию контроллера с аннотацией `@ResponseBody` для каждого метода.
Поэтому REST контроллеры по умолчанию возвращают XML/JSON вместо HTML.